\chapter{Files}

A file is simply a collection of related data.  In EMACS we are dealing
with text files -- named collections of text residing on a disk (or some
other storage medium).  You will recall that the major entities EMACS
deals with are buffers.  Disk-based versions of files are only active in
EMACS when you are reading into or writing out of buffers.  As we have
already seen, buffers and physical files are linked by associated
filenames.  For example, the buffer ``ch7.txt" which is associated with
the physical disk file ``ch7.txt." You will notice that the file is
usually specified by the drive name or (in the case of a hard drive) a
path.  Thus you can specify full filenames in EMACS,

e.g. disk:$\backslash${}directories$\backslash${}filename.extension

If you do not specify a disk and directories, the default disk is used.

IMPORTANT -- If you do not explicitly save your buffer to a file, all your
edits will be lost when you leave EMACS (although EMACS will prompt you
when you are about to lose edits by exiting).  In addition, EMACS does
not protect your disk-based files from overwriting when it saves files.
Thus when you instruct EMACS to save a file to disk, it will create a
file if the specified file doesn't exist, or it will overwrite the
previously saved version of the file thus replacing it.  Your old
version is gone forever.

If you are at all unsure about your edits, or if (for any reason) you
wish to keep previous versions of a file, you can change the name of the
associated file with the command {\bf{}\^{}X-N}.  When this file is saved
to disk, EMACS will create a new physical file under the new name.  The
earlier disk file will be preserved.

For example, let's load the file {\bf{}fang.txt} into EMACS.  Now, type
{\bf{}\^{}X-N}.  The EMACS command line prompts ``name:".  Enter a new name
for the file -- say {\bf{}new.txt} and press $<${}NL$>${}.  The file will be
saved under the new filename, and your disk directory will show both
{\bf{}fang.txt} and {\bf{}new.txt}.

An alternative method is to write the file directly to disk under a new
filename.  Let's pull our ``publish.txt" file into EMACS.  To write this
file under another filename, type {\bf{}\^{}X-\^{}W}.  EMACS will prompt
you ``write file:".  Enter an alternate filename -- {\bf{}desktop.txt}.
Your file will be saved as the physical file ``desktop.txt".

Note that in the examples above, although you have changed the names of
the related files, the buffer names remain the same.  However, when you
pull the physical file back into EMACS, you will find that the buffer
name now relates to the filename.

For example -- You are working with a buffer ``fang.txt" with the related
file ``fang.txt".  You change the name of the file to ``new.txt".  EMACS
now shows you working with the buffer ``fang.txt" and the related file
``new.txt".  Now pull the file ``new.txt" into EMACS.  Notice that the
buffer name has now changed to ``new.txt".

If for any reason a conflict of buffer names occurs,(if you have files
of the same name on different drives for example) EMACS will prompt
you ``use buffer:".  Enter an alternative buffer name if you need to.

For a list of file related commands (including some we`ve already
seen), see the summary page.
%\newpage
\section{Chapter \thechapter{} Summary}

In Chapter \thechapter{} you learned some of the more advanced
concepts of file naming and manipulation.  The relationship between
files and buffers was discussed in some detail.

\begin{tabular}{llp{4in}}
Key Binding & Keystroke & Effect \\ \hline
Save-file & {\bf{}\^{}X-\^{}S} & Saves contents of current buffer with
associated filename on default disk/directory (if not specified) \\
Write-File & {\bf{}\^{}X-\^{}W} & Current buffer contents will be
saved under specified name \\
Change-File-name
 & {\bf{}\^{}X-N} & The associated filename is changed
(or associated if not previously
specified) as specified \\
Find-File & {\bf{}\^{}X-\^{}F} & Reads specified file into buffer and
switches you to that buffer, or switches
to buffer in which the file has previously
been read \\
Read-File & {\bf{}\^{}X-\^{}R} & Reads file into buffer thus overwriting
buffer contents.  If file has already
been read into another buffer, you will
be switched to it \\
View-File & {\bf{}\^{}X-\^{}V} & The same as read-file except the buffer
is automatically put into VIEW mode thus
preventing any changes from being made \\
\end{tabular}

\chapter{Screen Formatting}

\section{Wrapping Text}

As we learned in the introduction, EMACS is not a word processor, but an
editor.  Some simple formatting options are available however, although
in most cases they will not affect the appearence of the finished text
\index{wrapping text} when it is run through the formatter.  We have
already encountered WRAP mode which wraps lines longer than a certain
length (default is 72 characters).  You will recall that WRAP is enabled
by entering {\bf{}\^{}X-M} and responding to the command line prompt with
{\bf{}wrap}.

You can also set your own wrap margin with the command {\bf{}\^{}X-F}
{\it{}set-fill-column} \index{set-fill-column}.  Notice EMACS responds
``[Fill column is 1]." Now try typing some text.  You'll notice some very
strange things happening -- your text wraps at every word!! This effect
occurs because the set wrap margin command must be preceeded by a
numeric argument or EMACS sets it to the first column.  Thus any text
you type that extends past the first column will wrap at the most
convenient line break.

To reset the wrap column to 72 characters, press the
{\bf{}$<${}META$>${}} key and enter 72.  EMACS will respond ``Arg:
72".  Now press {\bf\^{}X-F}.  EMACS will respond ``[Fill column is
72]".  Your text will again wrap at the margin you've been using up to
this point.

\section{Reformatting Paragraphs}

After an intensive editing session, you may find that you have
paragraphs containing lines of differing lengths.  Although this
disparity will not affect the formatted text, aesthetic and technical
concerns may make it desirable to have consistent paragraph blocks on
the screen.  If you are in WRAP mode, you can reformat a paragraph with
the command {\bf{}M-Q} {\it{}fill-paragraph} \index{fill-paragraph}.  This
command `fills' the current paragraph reformatting it so all the lines
are filled and wrap logically.  The process is complex, and (especially
with longer paragraphs) may take a little time.

\section{Changing Case}

There may be occasions when you find it necessary to change the case of
the text you've entered.  EMACS allows you to change the case of even
large amounts of text with ease.  Let's try and convert a few of the
office traditionalists to the joy of word processing.  Type in the
following text:

\begin{verbatim}
        Throw away your typewriter and learn to use a word processor.
        Word processing is relatively easy to learn and will increase
        your productivity enormously.  Enter the Computer Age and find
        out just how much fun it can be!!
\end{verbatim}

Let's give it a little more impact by capitalizing the first four
words.  The first step is to define the region of text just as you
would if you were doing an extensive deletion.  Set the mark at the
beginning of the paragraph with {\bf{}M-$<${}space$>${}}
{\it{}set-mark} and move the cursor to the space beyond ``typewriter."
Now enter {\bf{}\^{}X-\^{}U} {\it{}case-region-upper}.  Your text
should now look like this:

\begin{verbatim}
        THROW AWAY YOUR TYPEWRITER and learn to use a word processor.
        Word processing is relatively easy to learn and will increase
        your productivity enormously.  Enter the Computer Age and find
        out just how much fun it can be!!
\end{verbatim}

If you want to change the text back to lower case, type {\bf{}\^{}X-\^{}L}
{\it{}case-region-lower} \index{case-region-lower}.  You can also
capitalize individual words.  To capitalize the word ``fun", position the
cursor in front of the word and type {\bf{}M-U} {\it{}case-word-upper}
\index{case-word-upper}.  The word is now capitalized.  To change it
back to lower case, move the cursor back to the beginning of the word
and type {\bf{}M-L} {\it{}case-word-lower} \index{case-word-lower}.

You may also capitalize individual letters in EMACS.  The command
{\bf{}M-C} {\it{}case-word-capitalize} \index{case-word-capitalize}
capitalizes the first letter after the point.  This command would
normally be issued with the cursor positioned in front of the first
letter of the word you wish to capitalize.  If you issue it in the
middle of a word, you can end up with some strAnge looking text.

\section{Tabs}

Unless your formatter is instructed to take screen text literally (as
MicroSCRIBE does in the `verbatim' environment for example), tabs in
EMACS generally affect screen formatting only.

When EMACS is first started, it sets the default tab to every eighth
column.  As long as you stay with default, every time you press the tab
key a tab character, {\bf{}\^{}I} is inserted.  This character, like other
control characters, is invisible -- but it makes a subtle and
significant difference to your file and editing.

For example, in default mode, press the tab key and then type the word
{\bf{}Test}.  ``Test" appears at the eighth column.  Move your cursor to the
beginning of the word and delete the backward character.  The word
doesn't move back just one character, but flushes to the left margin.
The reason for this behavior is easily explained.  In tab default, EMACS
inserts a `real' tab character when you press the tab key.  This
character is inserted at the default position, but NO SPACES are
inserted between the tab character and the margin (or previous tab
character).  As you will recall, EMACS only recognizes characters (such
as spaces or letters) and thus when the tab character is removed, the
text beyond the tab is flushed back to the margin or previous tab mark.

This situation changes if you alter the default configuration.  The
default value may be changed by entering a numeric argument before
pressing the tab key.  As we saw earlier, pressing the {\bf{}META} key and
entering a number allows you to specify how EMACS performs a given
action.  In this case, let's specify an argument of 10 and hit the tab
key.

Now hit the tab key again and type {\bf{}Test}.  Notice the word now
appears at the tenth column.  Now move to the beginning of the word and
delete the backward character.  ``Test" moves back by one character.

EMACS behaves differently in these circumstances because the {\bf{}\^{}I}
\index{tab handling} {\it{}handle-tab} \index{handle-tab} function deals
with tabbing in two distinct ways.  In default conditions, or if the
numeric argument of zero is used, {\it{}handle-tab} inserts a true tab
character.  If, however, a non-zero numeric argument is specified,
{\it{}handle-tab} inserts the correct number of spaces needed to position
the cursor at the next specified tab position.  It does NOT insert the
single tab character and hence any editing functions should take account
of the number of spaces between tabbed columns.

Many times you would like to take a line which has been created using
the tab character and change it to use just spaces.  The command
{\bf{}\^{}X-\^{}D} {\it{}detab-line} \index{detab-line} changes any
tabs from the point to the end of the current line into the right
number of spaces so the line does not change.  This is very usefull
for times when the file must be printed or transfered to a machine
which does not understand tabs.

Also, the inverse command, {\bf{}\^{}X-\^{}E} {\it{}entab-lines}
\index{entab-lines} changes multiple spaces to tabs where possible.
This is a good way to shrink the size of large documents, escpecially
with data tables.  Both of these commands can take a numeric argument
which will be interpeted as the number of lines to en/detab.
%\newpage
\section{Chapter \thechapter{} Summary}

In Chapter \thechapter{} introduced some of the formatting features of
EMACS. Text-wrap, paragraph reformatting, and tabs were discussed in
some detail.  The commands in the following table were covered in the
chapter.

\begin{tabular}{llp{266pt}}
Key Binding & Keystroke &     Effect \\ \hline

Add-Mode/WRAP & {\bf{}\^{}X-M}[WRAP] & Add wrap mode to current buffer \\

Delete-Mode/WRAP & {\bf{}\^{}X-\^{}M}[WRAP] & Remove wrap mode from
current buffer \\

Set-Fill-Column & {\bf{}\^{}X-F}  & Set fill column to given numeric
argument  \\

Fill-Paragraph & {\bf{}M-Q} & Logically reformats the current
paragraph\\

Case-Word-Upper  & {\bf{}M-U} & Text from point to end of the
current word is changed to uppercase\\

Case-Word-Lower  & {\bf{}M-L} & Text from point to end of the
current word is changed to lowercase\\

Case-Word-Capitalize & {\bf{}M-C} & First word (or letter) after the
point is capitalized\\

Case-Region-Upper & {\bf{}\^{}X-\^{}U} & The current region is uppercased\\

Case-Region-Lower & {\bf{}\^{}X-\^{}L} & The current region is lowercased\\

Handle-Tab & {\bf{}\^{}I} & Tab interval is set to the given
numeric argument\\

Entab-Line & {\bf{}\^{}X-\^{}E} & Changes multiple spaces to tabs
characters where possible\\

Detab-Line & {\bf{}\^{}X-\^{}D} & Changes tab characters to the
apprpriate number of spaces\\

\end{tabular}
\chapter{Keyboard Macros}

In many applications, it may be necessary to repeat a series of
characters or commands frequently.  For example, a paper may require the
frequent repetition of a complex formula or a long name.  You may also
have a series of EMACS commands that you invoke frequently.  Keyboard
macros offer a convenient method of recording and repeating these
commands.

Imagine, for example, you are writing a scholarly paper on {\it{}Asplenium
platyneuron}, the spleenwort fern.  Even the dedicated botanist would
probably find it a task bordering on the agonizing to type
{\it{}Asplenium platyneuron} frequently throughout the paper.  An
alternative method is `record' the name in a keyboard macro.  Try it
yourself.

The command {\bf{}\^{}X-(} {\it{}begin-macro} \index{begin-macro}
starts recording the all the keystrokes and commands you input.  After
you've typed it, enter {\bf{}Asplenium platyneuron}.  To stop
recording, type {\bf{}\^{}X-)} {\it{}end-macro} \index{end-macro}.
EMACS has stored all the keystrokes between the two commands.  To
repeat the name you've stored, just enter {\bf{}\^{}X-E}
{\it{}execute-macro} \index{execute-macro}, and the name ``Asplenium
platyneuron" appears.  You can repeat this action as often as you
want, and of course as with any EMACS command, you may preceed it with
a numerical argument.

Because EMACS records keystrokes, you may freely intermix commands and
text.  Unfortunately, you can only store one macro at a time.  Thus, if
you begin to record another macro, the previously defined macro is
lost. Be careful to ensure that you've finished with one macro before
defining another.  If you have a series of commands that you would like
to `record' for future use, use the macro or procedure facilities
detailed in chapter 11.
%\newpage
\section{Chapter \thechapter{} Summary}

Chapter \thechapter{} covered keyboard macros.  You learned how to
record keystrokes and how to repeat the stored sequence.

\begin{tabular}{llp{4in}}
Key Binding & Keystroke & Effect \\ \hline
Start-Macro & {\bf{}\^{}X-(} & Starts recording all keyboard input\\

End-Macro & {\bf{}\^{}X-)} & Stops recording keystrokes for macro\\

Execute-Macro & {\bf{}\^{}X-E} & Entire sequence of recorded
keystrokes is replayed\\

\end{tabular}
\chapter{MicroEMACS Macros}

Macros are programs that are used to customize the editor and to
perform complicated editing tasks.  They may be stored in files or
buffers and may be executed using an appropriate command, or bound to
a particular keystroke.  Portions of the standard start-up file are
implement via macros, as well as the example menu system.  The
{\it{}execute-macro-$<${}n$>${}} \index{execute-macro-$<${}n$>${}}
commands cause the macro, numbered from 1 to 40, to be executed.  The
{\it{}execute-file} \index{execute-file} command allows you to execute
a macro stored in a disk file, and the {\it{}execute-buffer}
\index{execute-buffer} command allows you to execute a macro stored in
a buffer.  Macros are stored for easy execution by executing files
that contain the store-macro command.

There are many different aspects to the macro langage within
MicroEMACS.  Editor commands are the various commands that manipulate
text, buffers, windows, etc, within the editor.  Directives are commands
which control what lines get executed within a macro.  Also there are
various types of variables.  Environmental variables both control and
report on different aspects of the editor.  User variables hold string
values which may be changed and inspected.  Buffer variables allow text
to be placed into variables.  Interactive variables allow the program to
prompt the user for information.  Functions can be used to manipulate
all these variables.

\section{Variables}

Variables in MicroEMACS can be used to return values within
expressions, as repeat counts to editing commands, or as text to be
inserted into buffers and messages.  The value of these variables is
set using the {\it{}set} ({\bf{}\^{}X-A}) command.  For example, to
set the current fill column to 64 characters, the following macro line
would be used:

\begin{verbatim}
        set $fillcol 64
\end{verbatim}

or to have the contents of {\bf{}\%name} inserted at the point in the
current buffer, the command to use would be:

\begin{verbatim}
        insert-string %name
\end{verbatim}
%\newpage
\subsection{Environmental Variables}

These variables are used to change different aspects of the way
the editor works.  Also they will return the current settings if used as
part of an expresion.  All environmental variable names begin with a
dollar sign (\$) and are in lower case.

\begin{tabular}{lp{5in}}
\$fillcol & Current fill column \\

\$pagelen & Number of screen lines used currently \\

\$curwidth & Number of columns used currently \\

\$curcol & Current column of point in current buffer \\

\$curline & Current line of point in current buffer \\

\$flicker & Flicker Flag set to TRUE if IBM CGA set to FALSE for most
others \\

\$cbufname & Name of the current buffer \\

\$cfname & File name of the current buffer \\

\$sres & Current screen resolution (CGA, MONO or EGA on the IBM-PC driver.
LOW, MEDIUM, HIGH or DENSE on the Atari ST1040,
NORMAL on all others) \\

\$debug & Flag to trigger macro debugging (try it... you'll like it!) \\

\$status & return status of the success of the last command
(TRUE or FALSE) usually used with !force \\

\$palette & string used to control the palette register
settings on graphics versions.  The usual form
consists of groups of three octal digits
setting the red, green, and blue levels. \\

\$asave & The number of inserted characters between
automatic file-saves in ASAVE mode. \\

\$acount & The countdown of inserted characters until
the next save-file. \\

\$lastkey & Last keyboard character typed \\

\$curchar & Character currently at the point \\

\$discmd & Flag to disable the echoing of messages
on the command line \\

\$version & Contains the current MicroEMACS version number \\

\$progname & Always contains the string ``MicroEMACS" for
standard MicroEMACS. Could be something else
if used as part of someone else's program \\

\$seed & integer seed of the random number generator \\

\$disinp & Flag to disable the echoing of characters during command
line input \\

\end{tabular}

Obviously, many more of these variables will be availible in
future releases of MicroEMACS. (Yes, send a vote for your favorite new
environmental variables today).

\subsection{User variables}

User variables allow you, the user, to store strings and
manipulate them.  These strings can be pieces of text, numbers (in text
form), or the logical values {\bf{}TRUE} and {\bf{}FALSE}.  These variables
can be combined, tested, inserted into buffers, and otherwise used to
control the way your macros execute.  At the moment, up to 100 user
variables may be in use in one editing session.  All users variable
names must begin with a percent sign (\%) and may contain any printing
characters.  Only the first 10 characters are significant (ie
differences beyond the tenth character are ignored).  Most operators
will truncate strings to a length of 128 characters.

\subsection{Buffer Variables}

Buffer variables are special in that they can only be queried
and cannot be set.  What buffer variables are is a way to take text from
a buffer and place it in a variable. For example, if I have a buffer by
the name of RIGEL2, and it contains the text:

\begin{verbatim}
        Richmond
        Lafayette
        <*>Bloomington      (where <*> is the current point)
        Indianapolis
        Gary
        =* MicroEMACS 3.8i (WRAP) == rigel2 == File: /data/rigel2.txt =====
\end{verbatim}

and within a command I reference \#rigel2, like:

\begin{verbatim}
        insert-string \#rigel2
\end{verbatim}

MicroEMACS would start at the current point in the RIGEL2
buffer and grab all the text up to the end of that line and pass that
back.  Then it would advance the point to the beginning of the next line.
Thus, after our last command executes, the string ``Bloomington" gets
inserted into the current buffer, and the buffer RIGEL2 now looks like
this:

\begin{verbatim}
        Richmond
        Lafayette
        Bloomington
        <*>Indianapolis     (where <*> is the current point)
        Gary
        =* MicroEMACS 3.8i (WRAP) == rigel2 == File: /data/rigel2.txt =====
\end{verbatim}

as you have probably noticed, a buffer variable consists of the
buffer name, preceded by a pound sign (\#).

\subsection{Interactive variables}

Interactive variables are actually a method to prompt the user
for a string.  This is done by using an at sign (@) followed either with
a quoted string, or a variable containing a string.  The string is the
placed on the bottom line, and the editor waits for the user to type in
a string.  Then the string typed in by the users is returned as the
value of the interactive variable.  For example:

\begin{verbatim}
        set %quest "What file? "
        find-file @%quest
\end{verbatim}

will ask the user for a file name, and then attempt to find it.

\section{Functions}

Functions can be used to manipulate variables in various ways.
Functions can have one, two, or three arguments.  These arguments will
always be placed after the function on the current command line.  For
example, if we wanted to increase the current fill column by two, using
emacs's set ({\bf{}\^{}X-A}) command, we would write:

\begin{verbatim}
        set $fillcol &add $fillcol 2
         \      \      \      \     \____second operand
          \      \      \      \_________first operand
           \      \      \_______________function to execute
            \      \_____________________variable to set
             \___________________________set (^X-A) command
\end{verbatim}

Function names always begin with the ampresand (\&) character,
and are only significant to the first three characters after the
ampresand.  Functions will normal expect one of three types of
arguments, and will automatically convert types when needed.

\begin{description}

\item[$<${}num$>${}] an ascii string of digits which is interpeted as
a numeric value.  Any string which does not start with a digit or a
minus sign (-) will be considered zero.

\item[$<${}str$>${}] An arbitrary string of characters.  At the
moment, strings are limited to 128 characters in length.

\item[$<${}log$>${}] A logical value consisting of the string ``TRUE"
or ``FALSE".  Numeric strings will also evaluate to ``FALSE" if they
are equal to zero, and ``TRUE" if they are non-zero.  Arbitrary text
strings will have the value of ``FALSE".

\end{description}

A list of the currently availible functions follows: (Once
again, send in those votes on what kind of functions you would like to
see added!) Functions are always used in lower case, the uppercase
letters in the function table are the short form of the function (ie
\&div for \&divide).

\begin{tabular}{p{.8in}p{1.7in}p{250pt}}
\multicolumn{3}{c}{Numeric Functions:  (returns $<${}num$>${})}\\ \hline
\&ADD & $<${}num$>${} $<${}num$>${} & Add two numbers\\

\&SUB & $<${}num$>${} $<${}num$>${} & Subtract the second number from
the first\\

\&TIMes & $<${}num$>${} $<${}num$>${} & Multiply two numbers\\

\&DIVide & $<${}num$>${} $<${}num$>${} & Divide the first number by
the second giving an integer result\\

\&MOD & $<${}num$>${} $<${}num$>${} & Return the reminder of dividing the
first number by the second\\

\&NEGate & $<${}neg$>${} & Multiply the arg by -1\\

\&LENgth & $<${}str$>${} & Returns length of string\\

\&ASCii & $<${}str$>${} & Return the ascii code of the first
character in $<${}str$>${}\\

\&RND & $<${}num$>${} & Returns a random integer between 1 and
$<${}num$>${}\\

\&ABS & $<${}num$>${} & Returns the absolute value of $<${}num$>${}\\

\end{tabular}

\begin{tabular}{p{.8in}p{1.7in}p{250pt}}
\multicolumn{3}{c}{String manipulation functions:
(returns $<${}str$>${})}\\ \hline

\&CAT & $<${}str$>${} $<${}str$>${} & Concatinate the two strings to
form one\\

\&LEFt & $<${}str$>${} $<${}num$>${} & return the $<${}num$>${}
leftmost characters from $<${}str$>${}\\

\&RIGht & $<${}str$>${} $<${}num$>${} & return the $<${}num$>${}
rightmost characters from $<${}str$>${}\\

\&MID & $<${}str$>${} $<${}num1$>${} $<${}num2$>${} & Starting from
$<${}num1$>${} position in $<${}str$>${}, return $<${}num2$>${}
characters.\\

\&UPPer & $<${}str$>${} & Uppercase $<${}str$>${}\\

\&LOWer & $<${}str$>${} & lowercase $<${}str$>${}\\

\&CHR & $<${}num$>${} & return a string with the character
represented by ascii code $<${}num$>${}\\

\&GTK & & return a string containing a single
keystroke from the user\\

\end{tabular}

\begin{tabular}{p{.8in}p{1.7in}p{250pt}}
\multicolumn{3}{c}{Logical Testing functions:(returns
$<${}log$>${})}\\ \hline

\&NOT & $<${}log$>${} & Return the opposite logical value\\

\&AND & $<${}log1$>${} $<${}log2$>${} & Returns TRUE if BOTH logical
arguments are TRUE\\

\&OR & $<${}log1$>${} $<${}log2$>${} & Returns TRUE if either argument
is TRUE\\

\&EQUal & $<${}num$>${} $<${}num$>${} & If $<${}num$>${} and
$<${}num$>${} are numerically equal, return TRUE\\

\&LESs & $<${}num1$>${} $<${}num2$>${} & If $<${}num1$>${} is less
than $<${}num2$>${}, return TRUE.\\

\&GREater & $<${}num1$>${} $<${}num2$>${} & If $<${}num1$>${} is
greater than, or equal to $<${}num2$>${}, return TRUE.\\

\&SEQual & $<${}str1$>${} $<${}str2$>${} & If the two strings are the
same, return TRUE.\\

\&SLEss & $<${}str1$>${} $<${}str2$>${} & If $<${}str1$>${} is less
alphabetically than $<${}str2$>${}, return TRUE.\\

\&SGReater & $<${}str1$>${} $<${}str2$>${} & If $<${}str1$>${} is
alphabetically greater than or equal to $<${}str2$>${}, return TRUE.\\

\end{tabular}

\begin{tabular}{p{.8in}p{1.7in}p{250pt}}
\multicolumn{3}{c}{Special Functions:}\\ \hline

\&INDirect & $<${}str$>${} & Evaluate $<${}str$>${} as a variable.\\

\end{tabular}

This last function deserves more explanation. The \&IND function
evaluates its argument, takes the resulting string, and then uses it as
a variable name.  For example, given the following code sequence:

\begin{verbatim}
        ; set up reference table

        set %one   "elephant"
        set %two   "giraffe"
        set %three "donkey"

        set %index "two"
        insert-string &ind %index
\end{verbatim}

the string ``giraffe" would have been inserted at the point in
the current buffer.  This indirection can be safely nested up to about
10 levels.

\section{Directives}

Directives are commands which only operate within an executing
macro, ie they do not make sense as a single command. As such, they
cannot be called up singly or bound to keystroke. Used within macros,
they control what lines are executed and in what order.

Directives always start with the exclamation mark (!) character
and must be the first thing placed on a line. Directives executed singly
(via the execute-command-line command) interactively will be ignored.

\subsection{!ENDM Directive}

This directive is used to terminate a macro being stored. For
example, if a file is being executed contains the text:

\begin{verbatim}
        ; Read in a file in view mode, and make the window red

        26      store-macro
                find-file @"File to view: "
                add-mode "view"
                add-mode "red"
        !endm

        write-message "[Consult macro has been loaded]"
\end{verbatim}

only the lines between the store-macro command and the !ENDM
directive are stored in macro 26.

\subsection{!FORCE Directive}

When MicroEMACS executes a macro, if any command fails, the
macro is terminated at that point. If a line is preceeded by a !FORCE
directive, execution continues whether the command succeeds or not. For
example:

\begin{verbatim}
        ; Merge the top two windows

        save-window           ;remember what window we are at
        1 next-window         ;go to the top window
        delete-window         ;merge it with the second window
        !force restore-window ;This will continue irregardless
        add-mode "red"
\end{verbatim}

\subsection{!IF, !ELSE, and !ENDIF Directives}

This directive allows statements only to be executed if a
condition specified in the directive is met.  Every line following the
!IF directive, until the first !ELSE or !ENDIF directive, is only
executed if the expresion following the !IF directive evaluates to a
TRUE value.  For example, the following macro segment creates the
portion of a text file automatically.  (yes believe me, this will be
easier to understand then that last explanation....)

\begin{verbatim}
        !if &sequal %curplace "timespace vortex"
                insert-string "First, rematerialize~n"
        !endif
        !if &sequal %planet "earth"        ;If we have landed on earth...
                !if &sequal %time "late 20th century"  ;and we are then
                        write-message "Contact U.N.I.T."
                !else
                        insert-string "Investigate the situation....~n"
                        insert-string "(SAY 'stay here Sara')~n"
                !endif
        !else
                set %conditions @"Atmosphere conditions outside? "
                !if &sequal %conditions "safe"
                        insert-string &cat "Go outside......" "~n"
                        insert-string "lock the door~n"
                !else
                        insert-string "Dematerialize..try somewhen else"
                        newline
                !endif
        !endif
\end{verbatim}

\subsection{!GOTO Directive}

Flow can be controlled within a MicroEMACS macro using the !GOTO
directive. It takes as an argument a label. A label consists of a line
starting with an asterick (*) and then an alphanumeric label.  Only
labels in the currently executing macro can be jumped to, and trying to
jump to a non-existing label terminates execution of a macro.  For
example..

\begin{verbatim}
        ;Create a block of DATA statements for a BASIC program

                insert-string "1000 DATA "
                set %linenum 1000

        *nxtin
                update-screen                ;make sure we see the changes
                set %data @"Next number: "
                !if &equal %data 0
                        !goto finish
                !endif

                !if &greater $curcol 60
                        2 delete-previous-character
                        newline
                        set %linenum &add %linenum 10
                        insert-string &cat %linenum " DATA "
                !endif

                insert-string &cat %data ", "
                !goto nxtin

        *finish

                2 delete-previous-character
                newline
\end{verbatim}

\subsection{!RETURN Directive}

The !RETURN Directive causes the current macro to exit, either
returning to the caller (if any) or to interactive mode.  For example:

\begin{verbatim}
        ;Check the monitor type and set %mtyp

        !if &sres "CGA"
                set %mtyp 1
                !return
        !else
                set %mtyp 2
        !endif

        insert-string "You are on a MONOCHROME machine!~n"
\end{verbatim}
\appendix
\chapter{MicroEMACS commands}

Below is a complete list of the commands in EMACS, the keys
normally used to do the command, and what the command does.  Remember,
on some computers there may also be additional ways of using a command
(cursor keys and special function keys for example).

\begin{tabular}{llp{300pt}}
Command & Binding & Meaning\\ \hline
abort-command &  \^{}G & This allows the user to abort out of any
command that is waiting for input\\

add-mode &  \^{}X-M & Add a mode to the current buffer\\

add-global-mode  &  M-M & Add a global mode for all new buffers\\

apropos  &  M-A & List out commands whose name contains
the string specified\\

backward-character &  \^{}B & Move one character to the left\\

begin-macro &  \^{}X-( & Begin recording a keyboard macro\\

beginning-of-file &  M-$<${} & Move to the beginning of the file in
the current buffer\\

beginning-of-line &  \^{}A & Move to the beginning of the current line\\

bind-to-key &  M-K & Bind a key to a function\\

buffer-position  &  \^{}X-= & List the position of the cursor in the
current window on the command line\\

case-region-lower &  \^{}X-\^{}L & Make a marked region all lower case\\

case-region-upper &  \^{}X-\^{}U & Make a marked region all upper case\\

case-word-capitalize &  M-C & Capitalize the following word\\

case-word-lower  &  M-L & Lower case the following word\\

case-word-upper  &  M-U & Upper case the following word\\

change-file-name &  \^{}X-N & Change the name of the file in the
 current buffer\\

change-screen-size &  M-\^{}S & Chnage the number of lines of the screen
currently being used\\

change-screen-width &  M-\^{}T & Change the number of columns of the
screen currently being used\\
\end{tabular}

\begin{tabular}{llp{287pt}}
Command & Binding & Meaning\\ \hline
clear-and-redraw &  \^{}L & Clear the physical screen and redraw it\\

clear-message-line & (none) & Clear the command line\\

copy-region &  M-W & Copy the currently marked region into
the kill buffer\\

count-words &  M-\^{}C & Count how many words, lines and
characters are in the current marked region\\

ctlx-prefix &  \^{}X & Change the key used as the \^{}X prefix\\

delete-blank-lines & \^{}X-\^{}O & Delete all blank lines around the
cursor\\

delete-buffer &  \^{}X-K & Delete a buffer which is not being
currently displayed in a window\\

delete-mode &  \^{}X-\^{}M & Turn off a mode in the current buffer\\

delete-global-mode &  M-\^{}M & Turn off a global mode\\

delete-next-character &  \^{}D & Delete the character following the cursor\\

delete-next-word &  M-D & Delete the word following the cursor\\

delete-other-windows &  \^{}X-1 & Make the current window cover the entire
screen\\

delete-previous-character & \^{}H & Delete the character to the left of the
cursor\\

delete-previous-word & M-\^{}H & Delete the word to the left of the
cursor\\

delete-window &  \^{}X-0 & Remove the current window from the screen\\

describe-bindings & (none) & Make a list of all legal commands\\

describe-key &  \^{}X-? & Describe what command is bound to a
keystroke sequence\\

detab-line &  \^{}X-\^{}D & Change all tabs in a line to the
equivilant spaces\\

end-macro &  \^{}X-) & stop recording a keyboard macro\\

end-of-file &  M-$>${} & Move cursor to the end of the current buffer\\

end-of-line &  \^{}E & Move to the end of the current line\\

entab-line &  \^{}X-\^{}E & Change multiple spaces to tabs where
possible\\

exchange-point-and-mark & \^{}X-\^{}X & Move cursor to the last marked spot,
make the original position be marked\\

execute-buffer & (none) & Execute a buffer as a macro\\

execute-command-line & (none) & Execute a line typed on the command
line as a macro command\\

execute-file &  FNB & Execute a file as a macro\\

execute-macro &  \^{}X-E & Execute the keyboard macro (play back
the recorded keystrokes)\\

execute-macro-$<${}n$>${} & (none) & Execute numbered macro
$<${}N$>${} where $<${}N$>${} is an integer from 1 to 40\\

execute-named-command &  M-X & Execute a command by name\\

execute-procedure &  M-\^{}E & Execute a procedure by name\\

exit-emacs &  \^{}X-\^{}C & Exit EMACS. If there are unwritten,
changed buffers EMACS will ask to confirm\\

fill-paragraph &  M-Q & Fill the current paragraph\\

filter-buffer &  \^{}X-\# & Filter the current buffer through an
external filter\\

find-file &  \^{}X-\^{}F & Find a file to edit in the current window\\

forward-character &  \^{}F & Move cursor one character to the right\\

goto-line &  M-G & Goto a numbered line\\

goto-matching-fence &  M-\^{}F & Goto the matching fence\\

grow-window &  \^{}X-\^{} & Make the current window larger\\
\end{tabular}

\begin{tabular}{llp{283pt}}
Command & Binding & Meaning\\ \hline
handle-tab &  \^{}I & Insert a tab or set tab stops\\

hunt-forward &  FN= & Hunt for the next match of the last
search string\\

hunt-backward &  FN$>${} & Hunt for the last match of the last
search string\\

help &  M-? & Read EMACS.HLP into a buffer and display it\\

i-shell  &  \^{}X-C & Shell up to a new command processor\\

incremental-search &  \^{}X-S & Search for a string, incrementally\\

insert-file &  \^{}X-\^{}I & insert a file at the cursor in the
current file\\

insert-space &  \^{}C & Insert a space to the right of the cursor\\

insert-string & (none) & Insert a string at the cursor\\

kill-paragraph &  M-\^{}W & Delete the current paragraph\\

kill-region &  \^{}W & Delete the current marked region, moving
it to the kill buffer\\

kill-to-end-of-line &  \^{}K & Delete the rest of the current line\\

list-buffers &  \^{}X-\^{}B & List all existing buffers\\

meta-prefix &  $<${}ESC$>${} & Key used to preceed all META commands\\

move-window-down & \^{}X-\^{}N & Move all the lines in the current
window down\\

move-window-up & \^{}X-\^{}P & Move all the lines in the current
window up\\

name-buffer &  M-\^{}N & Change the name of the current buffer\\

newline  &  \^{}M & Insert a $<${}NL$>${} at the cursor\\

newline-and-indent &  \^{}J & Insert a $<${}NL$>${} at the cursor and indent
the new line the same as the preceeding line\\

next-buffer &  \^{}X-X & Bring the next buffer in the list into
the current window\\

next-line &  \^{}N & Move the cursor down one line\\

next-page &  \^{}V & Move the cursor down one page\\

next-paragraph &  M-N & Move cursor to the next paragraph\\

next-window &  \^{}X-O & Move cursor to the next window\\

next-word &  M-F & Move coursor to the beginning of the
next word\\

open-line &  \^{}O & Open a line at the cursor\\

pipe-command &  \^{}X-@ & Execute an external command and place
its output in a buffer\\

previous-line &  \^{}P & Move cursor up one line\\

previous-page &  \^{}Z & Move cursor up one page\\

previous-paragraph &  M-P & Move back one paragraph\\

previous-window  &  \^{}X-P & Move the cursor to the last window\\

previous-word &  M-B & Move the cursor to the beginning of the
word to the left of the cursor\\

query-replace-string &  M-\^{}R & Reaplace all of one string with another
string, interactivly quering the user\\

quick-exit &  M-Z & Exit EMACS, writing out all changed buffers\\

quote-character  &  \^{}Q & Insert the next character literally\\

read-file &  \^{}X-\^{}R & Read a file into the current buffer\\

redraw-display &  M-\^{}L & Redraw the display, centering the
current line\\

resize-window &  \^{}X-W & Change the number of lines in the
current window\\

restore-window & (none) & Move cursor to the last saved window\\

replace-string &  M-R & Replace all occurences of one string
with another string from the cursor
to the end of the buffer\\

reverse-incremental-search & \^{}X-R & Search backwards, incrementally\\
\end{tabular}

\begin{tabular}{llp{300pt}}
Command & Binding & Meaning\\ \hline
run &  M-\^{}E & Execute a named procedure\\

save-file &  \^{}X-\^{}S & Save the current buffer if it is changed\\

save-window & (none) & Remember current window (to restore later)\\

scroll-next-up &  M-\^{}Z & Scroll the next window up\\

scroll-next-down &  M-\^{}V & Scroll the next window down\\

search-forward &  \^{}S & Search for a string\\

search-reverse &  \^{}R & Search backwards for a string\\

select-buffer &  \^{}X-B & Select a buffer to display in the
current window\\

set &  \^{}X-A & Set a variable to a value\\

set-encryption-key &  M-E & Set the encryption key of the current buffer\\

set-fill-column  &  \^{}X-F & Set the current fill column\\

set-mark & & Set the mark\\

shell-command &  \^{}X-! & Execute an external command\\

shrink-window &  \^{}X-\^{}Z & Make the current window smaller\\

split-current-window &  \^{}X-2 & Split the current window in two\\

store-macro & (none) & Store the following macro lines to a
numbered macro\\

store-procedure & (none) & Store the following macro lines to a
named procedure\\

transpose-characters &  \^{}T & Transpose the character at the cursor
with the character to the left\\

trim-line &  \^{}X-\^{}T & Trim any trailing whitespace from line\\

unbind-key &  M-\^{}K & Unbind a key from a function\\

universal-argument &  \^{}U & Execute the following command 4 times\\

unmark-buffer &  M-~ & Unmark the current buffer (so it is
no longer changed)\\

update-screen & (none) & Force a screen update during macro execution\\

view-file &  \^{}X-\^{}V & Find a file,and put it in view mode\\

wrap-word &  M-FNW & Wrap the current word, this is an
internal function\\

write-file &  \^{}X-\^{}W & Write the current buffer under a new
file name\\

write-message & (none) & Display a string on the command line\\

yank &  \^{}Y & yank the kill buffer into the current
buffer at the cursor\\
\end{tabular}
\chapter{MicroEMACS Bindings}

Below is a complete list of the key bindings used in MicroEMACS.
This can be used as a wall chart reference for MicroEMACS commands.

\begin{verbatim}
           [Default Key Bindings for MicroEmacs 3.8i]

 ^A   Move to start of line           ESC A   Apropos (list some commands)
 ^B   Move backward by characters     ESC B   Backup by words
 ^C   Insert space                    ESC C   Initial capitalize word
 ^D   Forward delete                  ESC D   Delete forward word
 ^E   Goto end of line                ESC E   Reset Encryption Key
 ^F   Move forward by characters      ESC F   Advance by words
 ^G   Abort out of things             ESC G   Go to a line
 ^H   Backward delete
 ^I   Insert tab/Set tab stops
 ^J   Insert CR-LF, then indent
 ^K   Kill forward                    ESC K   Bind Key to function
 ^L   Refresh the screen              ESC L   Lower case word
 ^M   Insert CR-LF                    ESC M   Add global mode
 ^N   Move forward by lines           ESC N   Goto End paragraph
 ^O   Open up a blank line
 ^P   Move backward by lines          ESC P   Goto Begining of paragraph
 ^Q   Insert literal                  ESC Q   Fill current paragraph
 ^R   Search backwards                ESC R   Search and replace
 ^S   Search forward
 ^T   Transpose characters
 ^U   Repeat command four times       ESC U   Upper case word
 ^V   Move forward by pages           ESC V   Move backward by pages
 ^W   Kill region                     ESC W   Copy region to kill buffer
 ^Y   Yank back from killbuffer       ESC X   Execute named command
 ^Z   Move backward by pages          ESC Z   Save all buffers and exit

 ESC ^C   Count words in region       ESC ~   Unmark current buffer
 ESC ^F   Goto matching fence         ESC !   Reposition window
 ESC ^H   Delete backward word        ESC <   Move to start of buffer
 ESC ^K   Unbind Key from function    ESC >   Move to end of buffer
 ESC ^L   Reposition window           ESC .   Set mark
 ESC ^M   Delete global mode          ESC space    Set mark
 ESC ^N   Rename current buffer       ESC rubout   Delete backward word
 ESC ^R   Search & replace w/query        rubout   Backward delete
 ESC ^S   Change screen rows
 ESC ^T   Change screen columns
 ESC ^V   Scroll next window down
 ESC ^W   Delete Paragraph
 ESC ^Z   Scroll next window up

 ^X ?   Describe a key             ^X !   Run 1 command in a subjob
 ^X =   Show the cursor position   ^X @   Pipe DOS command to buffer
 ^X ^   Enlarge display window     ^X #   Filter buffer thru DOS filter
 ^X 0   Delete current window      ^X (   Begin macro
 ^X 1   Delete other windows       ^X )   End macro
 ^X 2   Split current window
                                   ^X A   Set variable value
 ^X ^B   Display buffer list       ^X B   Switch a window to a buffer
 ^X ^C   Exit MicroEMACS           ^X C   Start a new command processer
                                   ^X D   Suspend MicroEMACS (BSD4.2 only)
                                   ^X E   Execute macro
 ^X ^F   Find file                 ^X F   Set fill column
 ^X ^I   Insert file
                                   ^X K   Delete buffer
 ^X ^L   Lower case region
 ^X ^M   Delete Mode               ^X M   Add a mode
 ^X ^N   Move window down          ^X N   Rename current filename
 ^X ^O   Delete blank lines        ^X O   Move to the next window
 ^X ^P   Move window up            ^X P   Move to the previous window
 ^X ^R   Get a file from disk      ^X R   Incremental reverse search
 ^X ^S   Save current file         ^X S   Incremental forward search
 ^X ^U   Upper case region
 ^X ^V   View file
 ^X ^W   Write a file to disk      ^X W   resize Window
 ^X ^X   Swap "." and mark         ^X X   Use next buffer
 ^X ^Z   Shrink window             ^X Z   Enlarge display window

Only under PCDOS:
 <ALT>-S Hunt forward        SHIFT <F1> - <F10>
 <ALT>-R Hunt backward           Execute macroes 1 - 10

                           Usable Modes
WRAP     Lines going past right margin "wrap" to a new line
VIEW     Read-Only mode where no modifications are allowed
CMODE    Change behavior of some commands to work with C better
EXACT    Exact case matching on search strings
OVER     Overwrite typed characters instead of inserting them
CRYPT    Current buffer will be encrypted on write, decrypted on read
MAGIC    Use regular expresion matching in searches
ASAVE    Save the file every 256 inserted characters

WHITE/CYAN/MAGENTA/YELLOW/BLUE/RED/GREEN/BLACK  Sets forground color
white/cyan/magenta/yellow/blue/red/green/black  Sets background color
\end{verbatim}
%\newpage
\chapter{Supported machines}

The following table lists all the hardware/compilers for which I
currently support MicroEMACS.  This is not exclusive of all machines
which MicroEMACS will run on, but I have either run it myself, or had a
first hand report of it running.

\begin{tabular}{lllp{137pt}}
Hardware &OS&Compiler &Comments\\ \hline

VAX 780&UNIX V5&native\\

&UNIX V7&native\\

&BSD 4.2&native &job control supported\\

&*VMS&native &only some terminals supported\\

NCR Tower &UNIX V5&native\\

Fortune 32:16 &UNIX V7&native\\

IBM-PC&MSDOS &LATTICE2.15 &Large CODE/Large DATA\\

& 2.0 \& 3.2 &AZTEC 3.4e   &Small CODE/Large DATA\\

&  &*MSC 4.0 \\

&&*MWC 86\\

HP150&MSDOS&Lattice 2.15 &Function key labels\\

&&&for the touch screen\\

HP110&MSDOS&Lattice 2.15\\

&&Aztec 3.4e\\

*Data General 10 & MSDOS&Lattice 2.15\\

*Texas Instruments Professional & MSDOS& Lattice 2.15\\

Amiga&Intuition & Lattice 3.03 & no mouse or menus yet\\

& &*Aztec 3\\

ST520&TOS&Lattice 3.10& no menus yet, no shell commands\\ %
\multicolumn{4}{c}{Systems to be supported (ie some code is already
written:)}\\

Macintosh& Finder 5.0& Aztec\\

\end{tabular}

*means that I do not own or have access to the listed compiler and/or
 machine and must rely upon others to help support it.
\chapter{Machine Dependent Notes}

This appendix lists some notes specific to individual
implementations of MicroEMACS. Every attempt has been made to allow
EMACS to be identical on all machines, but we have also tried to take
advantage of function keys, cursor keys, mice, and special screen modes
where possible.

\section{IBM-PC/XT/AT and its clones}

The IBM-PC family of computers is supported with a variety of
different display adapters.  EMACS will attempt to discover what adapter
is connected and use the proper driver for it.  Below is a list of the
currently supported video adapters:

\begin{tabular}{llp{236pt}}
Adapter & \$sres & Original mode used\\ \hline
Monochrome Graphics Adapter & MONO & MONO\\
Color Graphics Adapter & CGA & CGA\\
Enhanced graphics Adapter & EGA & CGA\\
\end{tabular}

EMACS also takes advatage of various function keys and the keys
on the keypad on an IBM-PC.  The function keys are initially not bound
to any particular functions (except by the emacs.rc startup file), but
the keypad keys do default to the following:

\begin{tabular}{ll}
Keypad key & Function\\ \hline
Home & beginning-of-file\\
CSRS UP & previous-line\\
Pg Up & previous-page\\
CSRS LEFT & backward-character\\
CSRS RIGHT & forward-character\\
End & end-of-file\\
CSRS DOWN & next-line\\
Pg Dn & Next-page\\
\end{tabular}

All these special keys are indicated in EMACS macroes by use of
the {\bf{}FN} prefix.  Below is a list of many of the keys and the codes
used to specify them.  Also the codes may be gotten by using the
describe-key (\^{}X-?) command on the suspect key.

\newpage
\begin{verbatim}
                        IBM PC function keys in MicroEmacs

        function        Function        ^function       Alt-function
 f1)      FN;             FNT             FN^             FNh
 f2)      FN<             FNU             FN_             FNi
 f3)      FN=             FNV             FN`             FNj
 f4)      FN>             FNW             FNa             FNk
 f5)      FN?             FNX             FNb             FNl
 f6)      FN@             FNY             FNc             FNm
 f7)      FNA             FNZ             FNd             FNn
 f8)      FNB             FN[             FNe             FNo
 f9)      FNC             FN\             FNf             FNp
f10)      FND             FN]             FNg             FNq

home)     FNG                             FNw
CuUp)     FNH
PgUp)     FNI                             FN (Alt 132)
CuLf)     FNK                             FNs
 5  )
CuRt)     FNM                             FNt
 End)     FNO                             FNu
CuDn)     FNP
PgDn)     FNQ                             FNv
 Ins)     FNR
 Del)     FNS
\end{verbatim}
%\newpage
\section{Atari 520/1040ST}

The ATARI ST family of computers have a dual personality.  They
may use either a monochrome or a color screen.  EMACS supports two
screen resolutions on each monitor.

\begin{tabular}{lllll}
Monitor & \$sres & size & \#color & \$palette format\\ \hline\\
Color & LOW & 40x25 & 16 & 000111222333444555666777\\
 & MEDIUM & 80x25 & 4 & 000111222333\\
Mono & HIGH & 80x25 & 2 & 000\\
 & DENSE & 80x40 & 2 & 000\\
\end{tabular}

The \$palette environment variable can be used to change what
color is associated with each color name.  With a color monitor, each
group of three digits indicates an octal number specifying the RED,
GREEN and BLUE levels of that color.  Each color digit can vary from 0
to 7.  For example, the initial setting of \$palette in LOW resolution is:

\begin{verbatim}
        000700070770007707077777

        which broken up is:

        000 700 070 770 007 707 077 777

        which means:

        000     Black
        700     Red
        070     Green
        770     Yellow
        007     Blue
        707     Magenta
        077     Cyan
        777     White
\end{verbatim}

{\it{}Note: DENSE mode is not yet supported in 3.8i.  It will be
soon}

Also the mouse generates FN prefix codes when moved, or when one
of the two buttons is pressed.  Initially the movement of the mouse is
bound to movement of the cursor, and the left mouse button generates a
set-mark (M-space) command.  The cursor keys and the function keys are
bound similarly to to IBM-PC.
%\newpage
\section{Amiga 1000}

The Commodore AMIGA 1000 version of MicroEMACS does not have
extensive support of the mouse or of pull down menus as of yet.  It does
however come up in a window, and it is possible to re-size it to run in
different sized windows.  The {\bf{}M-\^{}S} {\it{}change-screen-size}
\index{change-screen-size} takes its numeric argument as the new number
of lines for EMACS to use.  The {\bf{}M-\^{}T} {\it{}change-screen-width}
\index{change-screen-width} command allows you to change the number of
columns EMACS will use.  The defaults for these are 23 lines and 77
characters across for a full screen window.

{\bf Note about Compiling MicroEMACS:}
If you are compiling the sources on the AMIGA to produce an
executable image, and you are using the Lattice compiler, be sure to
give the CLI command `STACK 40000' before compiling to make sure the
compiler has sufficient stack space to successfully complete
compiliation.

%\newpage
\section{UNIX V5, V7, and BSD4.[23]}

MicroEMACS under UNIX utilizes the {\bf{}TERMCAP} \index{termcap}
library to provide machine independent screen functions.  Make sure that
termcap is availible and properly set on your account before attempting
to use MicroEMACS.

Under systems which support job control, you can use the
{\bf{}\^{}X-D} {\it{}suspend-emacs} \index{suspend-emacs} command to
place EMACS into the background.  This carries a much smaller overhead
than bringing up a new shell under EMACS.  EMACS will properly redraw
the screen when you bring it back to the forground.

With the addition of some very machine/operating system specific
code, EMACS can prevent two or more people from modifying the same file
at the same time.  \index{file locking} The upper level of a set of
functions to provide file locking exist in the source file {\bf{}LOCK.C}.
It requires two machine specific functions written and linked into EMACS
for it to operate properly.

\newpage
\begin{verbatim}
        char *dolock(fname)

        char *fname;

        dolock() locks a file, preventing others from modifying it. If
        it succeeds, it returns NULL, otherwise it returns a pointer to
        a string in the form "LOCK ERROR: explination".

        char *undolock(fname)

        char *fname;

        undolock() unlocks a file, allowing others to modifying it. If
        it succeeds, it returns NULL, otherwise it returns a pointer to
        a string in the form "LOCK ERROR: explination".
\end{verbatim}
