#!/bin/sh
# to extract, remove the header and type "sh filename"
if `test ! -s ./rbsb.c`
then
echo "Writing ./rbsb.c"
cat > ./rbsb.c << '\Rogue\Monster\'
/*
 *
 *  Rev 03-06-1988
 *  This file contains Unix specific code for setting terminal modes,
 *  very little is specific to ZMODEM or YMODEM per se (that code is in
 *  sz.c and rz.c).  The CRC-16 routines used by XMODEM, YMODEM, and ZMODEM
 *  are also in this file, a fast table driven macro version
 *
 *	V7/BSD HACKERS:  SEE NOTES UNDER mode(2) !!!
 *
 *   This file is #included so the main file can set parameters such as HOWMANY.
 *   See the main files (rz.c/sz.c) for compile instructions.
 */

#ifdef V7
#include <sys/types.h>
#include <sys/stat.h>
#include <sgtty.h>
#define OS "V7/BSD"
#ifdef LLITOUT
long Locmode;		/* Saved "local mode" for 4.x BSD "new driver" */
long Locbit = LLITOUT;	/* Bit SUPPOSED to disable output translations */
#endif
#endif

#ifndef OS
#ifndef USG
#define USG
#endif
#endif

#ifdef USG
#include <sys/types.h>
#include <sys/stat.h>
#include <termio.h>
#include <sys/ioctl.h>
#define OS "SYS III/V"
#define MODE2OK
#endif

#if HOWMANY  > 255
Howmany must be 255 or less
#endif

/*
 * return 1 iff stdout and stderr are different devices
 *  indicating this program operating with a modem on a
 *  different line
 */
int Fromcu;		/* Were called from cu or yam */
from_cu()
{
	struct stat a, b;

	fstat(1, &a); fstat(2, &b);
	Fromcu = a.st_rdev != b.st_rdev;
	return;
}
cucheck()
{
	if (Fromcu)
		fprintf(stderr,"Please read the manual page BUGS chapter!\r\n");
}


struct {
	unsigned baudr;
	int speedcode;
} speeds[] = {
	110,	B110,
	300,	B300,
	600,	B600,
	1200,	B1200,
	2400,	B2400,
	4800,	B4800,
	9600,	B9600,
	19200,	EXTA,
	38400,	EXTB,
	0,
};

int Twostop;		/* Use two stop bits */


#ifndef READCHECK
#ifdef FIONREAD
#define READCHECK
/*
 *  Return non 0 iff something to read from io descriptor f
 */
rdchk(f)
{
	static long lf;

	ioctl(f, FIONREAD, &lf);
	return ((int) lf);
}
#endif
#ifdef SV
#define READCHECK
#include <fcntl.h>

char checked = '\0' ;
/*
 * Nonblocking I/O is a bit different in System V, Release 2
 */
rdchk(f)
{
	int lf, savestat;

	savestat = fcntl(f, F_GETFL) ;
	fcntl(f, F_SETFL, savestat | O_NDELAY) ;
	lf = read(f, &checked, 1) ;
	fcntl(f, F_SETFL, savestat) ;
	return(lf) ;
}
#endif
#endif


static unsigned
getspeed(code)
{
	register n;

	for (n=0; speeds[n].baudr; ++n)
		if (speeds[n].speedcode == code)
			return speeds[n].baudr;
	return 0;
}



#ifdef ICANON
struct termio oldtty, tty;
#else
struct sgttyb oldtty, tty;
struct tchars oldtch, tch;
#endif

int iofd = 0;		/* File descriptor for ioctls & reads */

/*
 * mode(n)
 *  3: save old tty stat, set raw mode with flow control
 *  2: set XON/XOFF for sb/sz with ZMODEM or YMODEM-g
 *  1: save old tty stat, set raw mode 
 *  0: restore original tty mode
 */
mode(n)
{
	static did0 = FALSE;

	vfile("mode:%d", n);
	switch(n) {
#ifdef USG
	case 2:		/* Un-raw mode used by sz, sb when -g detected */
		if(!did0)
			(void) ioctl(iofd, TCGETA, &oldtty);
		tty = oldtty;

		tty.c_iflag = BRKINT|IXON;

		tty.c_oflag = 0;	/* Transparent output */

		tty.c_cflag &= ~PARENB;	/* Disable parity */
		tty.c_cflag |= CS8;	/* Set character size = 8 */
		if (Twostop)
			tty.c_cflag |= CSTOPB;	/* Set two stop bits */


#ifdef READCHECK
		tty.c_lflag = Zmodem ? 0 : ISIG;
		tty.c_cc[VINTR] = Zmodem ? -1:030;	/* Interrupt char */
#else
		tty.c_lflag = ISIG;
		tty.c_cc[VINTR] = Zmodem ? 03:030;	/* Interrupt char */
#endif
		tty.c_cc[VQUIT] = -1;			/* Quit char */
#ifdef NFGVMIN
		tty.c_cc[VMIN] = 1;
#else
		tty.c_cc[VMIN] = 3;	 /* This many chars satisfies reads */
#endif
		tty.c_cc[VTIME] = 1;	/* or in this many tenths of seconds */

		(void) ioctl(iofd, TCSETAW, &tty);
		did0 = TRUE;
		return OK;
	case 1:
	case 3:
		if(!did0)
			(void) ioctl(iofd, TCGETA, &oldtty);
		tty = oldtty;

		tty.c_iflag = n==3 ? (IGNBRK|IXOFF) : IGNBRK;

		 /* No echo, crlf mapping, INTR, QUIT, delays, no erase/kill */
		tty.c_lflag &= ~(ECHO | ICANON | ISIG);

		tty.c_oflag = 0;	/* Transparent output */

		tty.c_cflag &= ~PARENB;	/* Same baud rate, disable parity */
		tty.c_cflag |= CS8;	/* Set character size = 8 */
		if (Twostop)
			tty.c_cflag |= CSTOPB;	/* Set two stop bits */
#ifdef NFGVMIN
		tty.c_cc[VMIN] = 1; /* This many chars satisfies reads */
#else
		tty.c_cc[VMIN] = HOWMANY; /* This many chars satisfies reads */
#endif
		tty.c_cc[VTIME] = 1;	/* or in this many tenths of seconds */
		(void) ioctl(iofd, TCSETAW, &tty);
		did0 = TRUE;
		Baudrate = getspeed(tty.c_cflag & CBAUD);
		return OK;
#endif
#ifdef V7
	/*
	 *  NOTE: this should transmit all 8 bits and at the same time
	 *   respond to XOFF/XON flow control.  If no FIONREAD or other
	 *   READCHECK alternative, also must respond to INTRRUPT char
	 *   This won't work with V7.  It should with LLITOUT, but sorry.
	 */
	case 2:		/* Un-raw mode used by sz, sb when -g detected */
		if(!did0) {
			ioctl(iofd, TIOCEXCL, 0);
			ioctl(iofd, TIOCGETP, &oldtty);
			ioctl(iofd, TIOCGETC, &oldtch);
#ifdef LLITOUT
			ioctl(TIOCLGET, &Locmode);	/* Get "local mode" */
#endif
		}
		tty = oldtty;
		tch = oldtch;
#ifdef READCHECK
		tch.t_intrc = Zmodem ? -1:030;	/* Interrupt char */
#else
		tch.t_intrc = Zmodem ? 03:030;	/* Interrupt char */
#endif
		tty.sg_flags |= (ODDP|EVENP|CBREAK);
		tty.sg_flags &= ~(ALLDELAY|CRMOD|ECHO|LCASE);
		ioctl(iofd, TIOCSETP, &tty);
		ioctl(iofd, TIOCSETC, &tch);
#ifdef LLITOUT
		ioctl(TIOCLBIS, &Locbit);
#endif
		bibi(99);	/* un-raw doesn't work w/o lit out */
		did0 = TRUE;
		return OK;
	case 1:
	case 3:
		if(!did0) {
			ioctl(iofd, TIOCEXCL, 0);
			ioctl(iofd, TIOCGETP, &oldtty);
			ioctl(iofd, TIOCGETC, &oldtch);
#ifdef LLITOUT
			ioctl(TIOCLGET, &Locmode);	/* Get "local mode" */
#endif
		}
		tty = oldtty;
		tty.sg_flags |= RAW;
		tty.sg_flags &= ~ECHO;
		ioctl(iofd, TIOCSETP, &tty);
		did0 = TRUE;
		Baudrate = getspeed(tty.sg_ospeed);
		return OK;
#endif
	case 0:
		if(!did0)
			return ERROR;
#ifdef USG
		(void) ioctl(iofd, TCSBRK, 1);	/* Wait for output to drain */
		(void) ioctl(iofd, TCFLSH, 1);	/* Flush input queue */
		(void) ioctl(iofd, TCSETAW, &oldtty);	/* Restore modes */
		(void) ioctl(iofd, TCXONC,1);	/* Restart output */
#endif
#ifdef V7
		ioctl(iofd, TIOCSETP, &oldtty);
		ioctl(iofd, TIOCSETC, &oldtch);
		ioctl(iofd, TIOCNXCL, 0);
#ifdef LLITOUT
		ioctl(TIOCLSET, &Locmode);	/* Restore "local mode" */
#endif
#endif

		return OK;
	default:
		return ERROR;
	}
}

sendbrk()
{
#ifdef V7
#ifdef TIOCSBRK
#define CANBREAK
	sleep(1);
	ioctl(iofd, TIOCSBRK, 0);
	sleep(1);
	ioctl(iofd, TIOCCBRK, 0);
#endif
#endif
#ifdef USG
#define CANBREAK
	ioctl(iofd, TCSBRK, 0);
#endif
}


/* crctab calculated by Mark G. Mendel, Network Systems Corporation */
static unsigned short crctab[256] = {
    0x0000,  0x1021,  0x2042,  0x3063,  0x4084,  0x50a5,  0x60c6,  0x70e7,
    0x8108,  0x9129,  0xa14a,  0xb16b,  0xc18c,  0xd1ad,  0xe1ce,  0xf1ef,
    0x1231,  0x0210,  0x3273,  0x2252,  0x52b5,  0x4294,  0x72f7,  0x62d6,
    0x9339,  0x8318,  0xb37b,  0xa35a,  0xd3bd,  0xc39c,  0xf3ff,  0xe3de,
    0x2462,  0x3443,  0x0420,  0x1401,  0x64e6,  0x74c7,  0x44a4,  0x5485,
    0xa56a,  0xb54b,  0x8528,  0x9509,  0xe5ee,  0xf5cf,  0xc5ac,  0xd58d,
    0x3653,  0x2672,  0x1611,  0x0630,  0x76d7,  0x66f6,  0x5695,  0x46b4,
    0xb75b,  0xa77a,  0x9719,  0x8738,  0xf7df,  0xe7fe,  0xd79d,  0xc7bc,
    0x48c4,  0x58e5,  0x6886,  0x78a7,  0x0840,  0x1861,  0x2802,  0x3823,
    0xc9cc,  0xd9ed,  0xe98e,  0xf9af,  0x8948,  0x9969,  0xa90a,  0xb92b,
    0x5af5,  0x4ad4,  0x7ab7,  0x6a96,  0x1a71,  0x0a50,  0x3a33,  0x2a12,
    0xdbfd,  0xcbdc,  0xfbbf,  0xeb9e,  0x9b79,  0x8b58,  0xbb3b,  0xab1a,
    0x6ca6,  0x7c87,  0x4ce4,  0x5cc5,  0x2c22,  0x3c03,  0x0c60,  0x1c41,
    0xedae,  0xfd8f,  0xcdec,  0xddcd,  0xad2a,  0xbd0b,  0x8d68,  0x9d49,
    0x7e97,  0x6eb6,  0x5ed5,  0x4ef4,  0x3e13,  0x2e32,  0x1e51,  0x0e70,
    0xff9f,  0xefbe,  0xdfdd,  0xcffc,  0xbf1b,  0xaf3a,  0x9f59,  0x8f78,
    0x9188,  0x81a9,  0xb1ca,  0xa1eb,  0xd10c,  0xc12d,  0xf14e,  0xe16f,
    0x1080,  0x00a1,  0x30c2,  0x20e3,  0x5004,  0x4025,  0x7046,  0x6067,
    0x83b9,  0x9398,  0xa3fb,  0xb3da,  0xc33d,  0xd31c,  0xe37f,  0xf35e,
    0x02b1,  0x1290,  0x22f3,  0x32d2,  0x4235,  0x5214,  0x6277,  0x7256,
    0xb5ea,  0xa5cb,  0x95a8,  0x8589,  0xf56e,  0xe54f,  0xd52c,  0xc50d,
    0x34e2,  0x24c3,  0x14a0,  0x0481,  0x7466,  0x6447,  0x5424,  0x4405,
    0xa7db,  0xb7fa,  0x8799,  0x97b8,  0xe75f,  0xf77e,  0xc71d,  0xd73c,
    0x26d3,  0x36f2,  0x0691,  0x16b0,  0x6657,  0x7676,  0x4615,  0x5634,
    0xd94c,  0xc96d,  0xf90e,  0xe92f,  0x99c8,  0x89e9,  0xb98a,  0xa9ab,
    0x5844,  0x4865,  0x7806,  0x6827,  0x18c0,  0x08e1,  0x3882,  0x28a3,
    0xcb7d,  0xdb5c,  0xeb3f,  0xfb1e,  0x8bf9,  0x9bd8,  0xabbb,  0xbb9a,
    0x4a75,  0x5a54,  0x6a37,  0x7a16,  0x0af1,  0x1ad0,  0x2ab3,  0x3a92,
    0xfd2e,  0xed0f,  0xdd6c,  0xcd4d,  0xbdaa,  0xad8b,  0x9de8,  0x8dc9,
    0x7c26,  0x6c07,  0x5c64,  0x4c45,  0x3ca2,  0x2c83,  0x1ce0,  0x0cc1,
    0xef1f,  0xff3e,  0xcf5d,  0xdf7c,  0xaf9b,  0xbfba,  0x8fd9,  0x9ff8,
    0x6e17,  0x7e36,  0x4e55,  0x5e74,  0x2e93,  0x3eb2,  0x0ed1,  0x1ef0
};

/*
 * updcrc macro derived from article Copyright (C) 1986 Stephen Satchell. 
 *  NOTE: First srgument must be in range 0 to 255.
 *        Second argument is referenced twice.
 * 
 * Programmers may incorporate any or all code into their programs, 
 * giving proper credit within the source. Publication of the 
 * source routines is permitted so long as proper credit is given 
 * to Stephen Satchell, Satchell Evaluations and Chuck Forsberg, 
 * Omen Technology.
 */

#define updcrc(cp, crc) ( crctab[((crc >> 8) & 255)] ^ (crc << 8) ^ cp)

/*
 * Copyright (C) 1986 Gary S. Brown.  You may use this program, or
 * code or tables extracted from it, as desired without restriction.
 */

/* First, the polynomial itself and its table of feedback terms.  The  */
/* polynomial is                                                       */
/* X^32+X^26+X^23+X^22+X^16+X^12+X^11+X^10+X^8+X^7+X^5+X^4+X^2+X^1+X^0 */
/* Note that we take it "backwards" and put the highest-order term in  */
/* the lowest-order bit.  The X^32 term is "implied"; the LSB is the   */
/* X^31 term, etc.  The X^0 term (usually shown as "+1") results in    */
/* the MSB being 1.                                                    */

/* Note that the usual hardware shift register implementation, which   */
/* is what we're using (we're merely optimizing it by doing eight-bit  */
/* chunks at a time) shifts bits into the lowest-order term.  In our   */
/* implementation, that means shifting towards the right.  Why do we   */
/* do it this way?  Because the calculated CRC must be transmitted in  */
/* order from highest-order term to lowest-order term.  UARTs transmit */
/* characters in order from LSB to MSB.  By storing the CRC this way,  */
/* we hand it to the UART in the order low-byte to high-byte; the UART */
/* sends each low-bit to hight-bit; and the result is transmission bit */
/* by bit from highest- to lowest-order term without requiring any bit */
/* shuffling on our part.  Reception works similarly.                  */

/* The feedback terms table consists of 256, 32-bit entries.  Notes:   */
/*                                                                     */
/*     The table can be generated at runtime if desired; code to do so */
/*     is shown later.  It might not be obvious, but the feedback      */
/*     terms simply represent the results of eight shift/xor opera-    */
/*     tions for all combinations of data and CRC register values.     */
/*                                                                     */
/*     The values must be right-shifted by eight bits by the "updcrc"  */
/*     logic; the shift must be unsigned (bring in zeroes).  On some   */
/*     hardware you could probably optimize the shift in assembler by  */
/*     using byte-swap instructions.                                   */

static long cr3tab[] = { /* CRC polynomial 0xedb88320 */
0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};

#ifdef NFGM
long
UPDC32(b, c)
long c;
{
	return (cr3tab[((int)c ^ b) & 0xff] ^ ((c >> 8) & 0x00FFFFFF));
}

#else

#define UPDC32(b, c) (cr3tab[((int)c ^ b) & 0xff] ^ ((c >> 8) & 0x00FFFFFF))
#endif

/* End of rbsb.c */
\Rogue\Monster\
else
  echo "will not over write ./rbsb.c"
fi
if [ `wc -c ./rbsb.c | awk '{printf $1}'` -ne 15222 ]
then
echo `wc -c ./rbsb.c | awk '{print "Got " $1 ", Expected " 15222}'`
fi
if `test ! -s ./minirb.c`
then
echo "Writing ./minirb.c"
cat > ./minirb.c << '\Rogue\Monster\'
/*
 * minirb.c By Chuck Forsberg Omen Technology INC
 *        "The High Reliability Communications Software"
 *
 * A bootstrap program for Unix to receive files from computers running
 *  YMODEM Batch (Professional-YAM, PowerCom, ZCOMM, etc.).
 *
 *  Minirb uses system(3) to call stty, avoiding system dependent code.
 *   program strips CR and CPMEOF (^Z) characters (see putsec()).
 *  Please refer to rz.c for comments, etc.
 */
char * Version = "minirb 2.00 05-25-87";

#include <stdio.h>
#include <signal.h>
#include <setjmp.h>

#define OK 0
#define FALSE 0
#define TRUE 1
#define ERROR (-1)
#define CAN ('X'&037)
#define SOH 1
#define STX 2
#define EOT 4
#define ACK 6
#define NAK 025
#define TIMEOUT (-2)
#define RETRYMAX 9
#define WCEOT (-10)

FILE *fout;
long Bytesleft;
int Blklen;
char secbuf[1024];
char linbuf[1024];
int Lleft=0;
jmp_buf tohere;

alrm() { longjmp(tohere, -1); }

bibi(n) {
 canit(); mode(0);
 fprintf(stderr, "minirb: caught signal %d; exiting", n);
 exit(128+n);
}

mode(n) {
 if (n) system("stty raw -echo");
 else system("stty echo -raw");
}

main() {
 mode(1);
 if (signal(SIGINT, bibi) == SIG_IGN) {
  signal(SIGINT, SIG_IGN); signal(SIGKILL, SIG_IGN);
 } else {
  signal(SIGINT, bibi); signal(SIGKILL, bibi);
 }
 printf("minirb: Now send file(s) with \042sb file ...\042 command\r\n");

 if (wcreceive()==ERROR)
  canit();
 mode(0); exit(0);
}

wcreceive() {
 for (;;) {
  if (wcrxpn(secbuf) == ERROR) break;
  if (secbuf[0]==0) return OK;
  if (procheader(secbuf)==ERROR || wcrx()==ERROR) break;
 }
 canit(); return ERROR;
}


wcrxpn(rpn) char *rpn; {
 register c;

 purgeline();
et_tu:
 sendline(NAK); Lleft=0;
 while ((c = wcgetsec(rpn, 100)) != 0) {
  if (c == WCEOT) { sendline(ACK); Lleft=0; readline(1); goto et_tu; }
  return ERROR;
 }
 sendline(ACK); return OK;
}

wcrx() {
 register int sectnum, sectcurr, sendchar, cblklen;

 sectnum=0; sendchar=NAK;
 for (;;) {
  sendline(sendchar); Lleft=0;
  sectcurr=wcgetsec(secbuf, 50);
  if (sectcurr==(sectnum+1 & 0377)) {
   sectnum++; cblklen = Bytesleft>Blklen ? Blklen:Bytesleft;
   putsec(secbuf, cblklen);
   if ((Bytesleft-=cblklen) < 0) Bytesleft = 0;
   sendchar=ACK;
  }
  else if (sectcurr==(sectnum&0377)) sendchar=ACK;
  else if (sectcurr==WCEOT) {
   if (fclose(fout)==ERROR) return ERROR;
   sendline(ACK); Lleft=0; return OK;
  }
  else if (sectcurr==ERROR) return ERROR;
  else return ERROR;
 }
}

wcgetsec(rxbuf, maxtime) char *rxbuf; int maxtime; {
 register checksum, wcj, firstch; register char *p; int sectcurr, errors;
 for (errors=0; errors<RETRYMAX; errors++) {
  if ((firstch=readline(maxtime))==STX) { Blklen=1024; goto get2; }
  if (firstch==SOH) {
   Blklen=128;
get2:
   sectcurr=readline(1); checksum=0;
   if ((sectcurr+(readline(1)))==0377) {
    for (p=rxbuf,wcj=Blklen; --wcj>=0; ) {
     if ((firstch=readline(1)) < 0) goto bilge;
     checksum += (*p++ = firstch);
    }
    if ((firstch=readline(1)) < 0) goto bilge;
    if (((checksum-firstch)&0377)==0) return sectcurr;
   }
  }
  else if (firstch==EOT) return WCEOT;
  else if (firstch==CAN) return ERROR;
bilge:
  while(readline(1)!=TIMEOUT)
   ;
  maxtime=40; sendline(NAK); Lleft=0;
 }
 canit(); return ERROR;
}

readline(timeout) int timeout; {
 register n; static char *cdq;

 if (--Lleft >= 0) return (*cdq++ & 0377);
 n = timeout/10;
 if (n < 2) n = 3;
 if (setjmp(tohere)) { Lleft = 0; return TIMEOUT; }
 signal(SIGALRM, alrm); alarm(n);
 Lleft=read(0, cdq=linbuf, 1024); alarm(0);
 if (Lleft < 1) return TIMEOUT;
 --Lleft; return (*cdq++ & 0377);
}

purgeline() { Lleft = 0; lseek(0, 0L, 2); }


procheader(name) char *name; {
 register char *p;

 Bytesleft = 2000000000L; p = name + 1 + strlen(name);
 if (*p) sscanf(p, "%ld", &Bytesleft);
 if ((fout=fopen(name, "w")) == NULL) return ERROR;
 return OK;
}

putsec(p, n) char *p; int n;
{ for (; --n>=0; ++p) if (*p != 015 && *p != 032) putc(*p, fout); }

sendline(c) { char d; d = c; write(1, &d, 1); }

char canistr[] = { 24,24,24,24,24,24,24,24,0 };

canit() { printf(canistr); Lleft=0; }

/* END of minirb.c */

\Rogue\Monster\
else
  echo "will not over write ./minirb.c"
fi
if [ `wc -c ./minirb.c | awk '{printf $1}'` -ne 4057 ]
then
echo `wc -c ./minirb.c | awk '{print "Got " $1 ", Expected " 4057}'`
fi
if `test ! -s ./minirb.1`
then
echo "Writing ./minirb.1"
cat > ./minirb.1 << '\Rogue\Monster\'
'\" Revision Level 
'\" Last Delta     09-08-87
.TH MINIRB 1 OMEN
.SH NAME
minirb \- Bootstrap YMODEM Batch file receive
.SH SYNOPSIS
.B minirb
.SH DESCRIPTION
.I Minirb
receives one or more files with YMODEM batch file transfer protocol.
.I Minirb
was developed for use as a bootstrap to simplify uploading of the longer
.I rz
and
.I sz
programs, such as are contained in the
.I rzsz.zoo
"zoo" archive or the
.I rzsz.sh
shell archive.
.SH SEE ALSO
YMODEM.DOC,
Professional-YAM manual,
sz(omen)
.SH NOTES
The source file
.I minirb.c
has been ruthlessly pruned
(4k, 175 lines)
to simplify uploading without benefit of
an error correcting file transfer protocol.
Do not reformat or add tabs to the source file
as this would complicate uploading.

Please read the uploading suggestions in the chapter
.I "File Transfer Basics"
in the Professional-YAM or ZCOMM user's manual.

.I Minirb
uses 8 bit checksum which may not be compatible with some programs
claiming to support YMODEM batch transfers.

.I Minirb
uses the
YMODEM header
file length information
to avoid storing extraneous characters.
.I Minirb
deletes carriage returns and CPMEOF (^Z) characters
encountered in uploaded files.

.I Minirb
calls stty(1) to set and reset raw tty mode.
\Rogue\Monster\
else
  echo "will not over write ./minirb.1"
fi
if [ `wc -c ./minirb.1 | awk '{printf $1}'` -ne 1241 ]
then
echo `wc -c ./minirb.1 | awk '{print "Got " $1 ", Expected " 1241}'`
fi
if `test ! -s ./rz.1`
then
echo "Writing ./rz.1"
cat > ./rz.1 << '\Rogue\Monster\'
'\" Revision Level 
'\" Last Delta     03-06-88
.TH RZ 1 OMEN
.SH NAME
rx, rb, rz \- XMODEM, YMODEM, ZMODEM (Batch) file receive
.SH SYNOPSIS
.B rz
.RB [\- "\ +1abepqtuv" ]
.br
.B rb
.RB [\- "\ +1abqtuv" ]
.br
.B rx
.RB [\- "\ 1abceqtuv" ]
.I file
.br
.B gz
.I "file ..."
.br
.RB [ \- ][ v ] rzCOMMAND
.SH DESCRIPTION
This program uses error correcting protocols to receive
files over a dial-in serial port from a variety of programs running under
PC-DOS, CP/M,
.SM Unix,
and other operating systems.
It is invoked from a shell prompt
manually, or automatically as a result of an
"sz file ..." command given to the calling program.

While
.I rz
is smart enough to be called from
.I cu(1),
very few versions of
.I cu(1)
are smart enough to allow
.I rz
to work properly.
Unix flavors of Professional-YAM are available for such dial-out application.


.B Rz
(Receive ZMODEM)
receives files with the ZMODEM batch protocol.
Pathnames are supplied by the sending program,
and directories are made if necessary (and possible).
Normally, the
"rz" command is automatically issued by the calling ZMODEM program,
but some defective ZMODEM implementations may require starting
.I rz
the old fashioned way.


.B Rb
receives file(s) with YMODEM,
accepting either standard 128 byte sectors or
1024 byte sectors
(YAM sb
.B -k
option).
The user should determine when
the 1024 byte block length
actually improves throughput without causing lost data
or even system crashes.

If True YMODEM (Omen Technology trademark) file information (file length, etc.)
is received,
the file length controls the number of bytes written to
the output dataset,
and the modify time and file mode
(iff non zero)
are set accordingly.

If no True YMODEM file information is received,
slashes in the pathname are changed to underscore,
and any trailing period in the pathname is eliminated.
This conversion is useful for files received from CP/M systems.
With YMODEM, each file name is converted to lower case
unless it contains one or more lower case letters.


.B Rx
receives a single
.I file
with XMODEM or XMODEM-1k protocol.
The user should determine when
the 1024 byte block length
actually improves throughput without causing problems.
The user must supply the file name to both sending and receiving programs.
Up to 1023 garbage characters may be added to the received file.

.B Gz
is a shell script which calls
.I sz
to command Pro-YAM or ZCOMM to transmit the specified files.
Pathnames used with
.I gz
must be escaped if they have special significance to the Unix shell.
.br
EXAMPLE:
gz "-a C:*.c D:*.h"


.B Rz
may be invoked as
.B rzCOMMAND
(with an optional leading \- as generated by login(1)).
For each received file,
.I rz
will pipe the file to ``COMMAND filename''
where filename is the name of the transmitted file
with the file contents as standard input.

Each file transfer is acknowledged when COMMAND exits with 0 status.
A non zero exit status terminates transfers.

A typical use for this form is
.I rzrmail
which calls rmail(1)
to post mail to the user specified by the transmitted file name.
For example, sending the file "caf" from a PC-DOS system to
.I rzrmail
on a
.SM Unix
system
would result in the contents of the DOS file "caf" being mailed to user "caf".

On some
.SM Unix
systems, the login directory must contain a link to
COMMAND as login sets SHELL=rsh which disallows absolute
pathnames.
If invoked with a leading ``v'',
.I rz
will report progress to /tmp/rzlog.
The following entry works for
.SM Unix
SYS III/V:
.ce
rzrmail::5:1::/bin:/usr/local/rzrmail
If the SHELL environment variable includes
.I "rsh"
or
.I "rksh"
(restricted shell),
.I rz
will not accept absolute pathnames
or references to a parent directory,
will not modify an existing file, and
removes any files received in error.

If
.B rz
is invoked with stdout and stderr to different datasets,
Verbose is set to 2, causing frame by frame progress reports
to stderr.
This may be disabled with the
.B q
option.

.PP
The meanings of the available options are:
.PP
.PD 0
.TP
.B 1
Use file descriptor 1 for ioctls and reads (Unix only).
By default, file descriptor 0 is used for ioctls and reads.
This option allows
.B rz
to be used with the
.I Professional-YAM
.B $
command
and some versions of ncu(1), but not cu(1).
.TP
.B a
Convert files to
.SM Unix
conventions by stripping carriage returns and all characters
beginning with the first Control Z (CP/M end of file).
.TP
.B b
Binary
(tell it like it is)
file transfer override.
.TP
.B c
Request 16 bit CRC.
XMODEM file transfers default to 8 bit checksum.
YMODEM and ZMODEM normally use 16 bit CRC.
.TP
.B D
Output file data to /dev/null; for testing.
.TP
.B e
Force sender to escape all control characters;
normally XON, XOFF, DLE, CR-@-CR, and Ctrl-X are escaped.
.TP
.B p
(ZMODEM) Protect: skip file if destination file exists.
.TP
.B q
Quiet suppresses verbosity.
.TP
.B "t tim"
Change timeout to
.I tim
tenths of seconds.
.TP
.B v
Verbose
causes a list of file
names to be appended to
/tmp/rzlog .
More v's generate more output.
.PD
.ne 6
.SH EXAMPLES
.RE
(Pro-YAM command)
.RS
.I <ALT-2>
.br
Pro-YAM Command:
.I "sz *.h *.c"
.br
(This automatically invokes
.I rz
on the connected system.)
.RE
.SH SEE ALSO
ZMODEM.DOC,
YMODEM.DOC,
IMP(CP/M),
Professional-YAM,
sz(omen),
usq(omen),
undos(omen)

Compile time options required
for various operating systems are described in the
source file.
.SH NOTES
Sending serial data to timesharing minicomputers
at sustained high speeds
has been known to cause lockups, system halts, kernel panics,
and occasional antisocial behaviour.
When experimenting with high speed input to a
system, consider rebooting the system
if the file transfers are not successful,
especially if the personality of the system appears altered.

The Unix "ulimit" parameter must be set high enough
to permit large file transfers.

The TTY input buffering on some systems may not allow long blocks
or streaming input at high speed.
You should suspect this problem when you
can't send data to the Unix system at high speeds using ZMODEM,
YMODEM-1k or XMODEM-1k,
when YMODEM with 128 byte blocks works properly.
If the system's tty line handling is really broken, the serial port
or the entire system may not survive the onslaught of long bursts
of high speed data.

The DSZ or Pro-YAM
.B "zmodem l"
numeric parameter may be set to a value between 64 and 1024 to limit the
burst length ("zmodem pl128").

32 bit CRC code courtesy Gary S. Brown.
Directory creation code from John Gilmore's PD TAR program.
.SH BUGS
Calling
.I rz
from most versions of cu(1) doesn't work because cu's receive process
fights
.I rz
for characters from the modem.

Programs that do not properly implement the specified file transfer protocol
may cause
.I sz
to "hang" the port for a minute or two.
Every reported instance of this problem has been corrected by using
ZCOMM, Pro-YAM, or other program with a correct implementation
of the specified protocol.

Many programs claiming to support YMODEM only support XMODEM with 1k blocks,
and they often don't get that quite right.

Pathnames are restricted to 127 characters.
In XMODEM single file mode, the pathname given on the command line
is still processed as described above.
The ASCII option\'s CR/LF to NL translation merely deletes CR\'s;
undos(omen) performs a more intelligent translation.
.SH "VMS VERSION"
Some of the #includes with file names enclosed with angle brackets <>
may need to have the angle brackets changed to "", or vice versa.

The VMS version does not set binary mode according to the incoming
file type.
Non binary file processing consists of stripping all characters beginning
with CPMEOF (^Z).

The VMS version does not set the file time.

At high speeds,
VMS sometimes loses incoming characters, resulting in retries
and degradation of throughput.

The mysterious
VMS C Standard I/O Package and RMS may interact to modify
file contents unexpectedly.

The VMS version does not support invocation as
.B rzCOMMAND .
ZMODEM has not yet been implemented on the VMS version.
.SH "ZMODEM CAPABILITIES"
.I Rz
supports incoming ZMODEM binary (-b), ASCII (-a),
protect (-p),
and append (-+)
requests, and ZMODEM command execution.
.SH FILES
rz.c, rbsb.c, zm.c, zmodem.h source files.

/tmp/rzlog stores debugging output generated with -vv option.
\Rogue\Monster\
else
  echo "will not over write ./rz.1"
fi
if [ `wc -c ./rz.1 | awk '{printf $1}'` -ne 8324 ]
then
echo `wc -c ./rz.1 | awk '{print "Got " $1 ", Expected " 8324}'`
fi
if `test ! -s ./sz.1`
then
echo "Writing ./sz.1"
cat > ./sz.1 << '\Rogue\Monster\'
'\" Revision Level 
'\" Last Delta     02-19-88
.TH SZ 1 OMEN
.SH NAME
sx, sb, sz \- XMODEM, YMODEM, ZMODEM file send
.SH SYNOPSIS
sz
.RB [\- +1abdefkLlNnopqTtuvyY ]
.I file ...
.br
sb
.RB [\- 1adfkqtuv ]
.I file ...
.br
sx
.RB [\- 1akqtuv ]
.I file
.br
sz
.RB [\- 1oqtv ]
.B "-c COMMAND"
.br
sz
.RB [\- 1oqtv ]
.B "-i COMMAND"
.br
sz -TT
.SH DESCRIPTION
.B Sz
uses the ZMODEM, YMODEM or XMODEM error correcting protocol to send
one or more files over a dial-in serial port to a variety of programs running under
PC-DOS, CP/M, Unix, VMS, and other operating systems.

While
.I rz
is smart enough to be called from
.I cu(1),
very few versions of
.I cu(1)
are smart enough to allow
.I sz
to work properly.
Unix flavors of Professional-YAM are available for such dial-out application.


.B Sz
sends one or more files with ZMODEM protocol.

ZMODEM
greatly simplifies file transfers compared to XMODEM.
In addition to a friendly user interface, ZMODEM
provides Personal Computer and other users
an efficient, accurate, and robust file transfer method.

ZMODEM provides complete
.B "END-TO-END"
data integrity between application programs.
ZMODEM's 32 bit CRC catches errors
that sneak into even the most advanced networks.

Advanced file management features include
AutoDownload (Automatic file Download initiated without user intervention),
Display of individual and total file lengths and transmission time estimates,
Crash Recovery,
selective file transfers,
and preservation of
exact file date and length.

Output from another program may be piped to
.B sz
for transmission by denoting standard input with "-":
.ce
ls -l | sz -
The program output is transmitted with the filename sPID.sz
where PID is the process ID of the
.B sz
program.
If the environment variable
.B ONAME
is set, that is used instead.
In this case, the Unix command:
.ce
ls -l | ONAME=con sz -ay -
will send a "file" to the PC-DOS console display.
The
.B -y
option instructs the receiver to open the file for writing unconditionally.
The
.B -a
option
causes the receiver to convert Unix newlines to PC-DOS carriage returns
and linefeeds.


.B Sb
batch sends one or more files with YMODEM or ZMODEM protocol.
The initial ZMODEM initialization is not sent.
When requested by the receiver,
.B sb
supports
.B YMODEM-g
with "cbreak" tty mode, XON/XOFF flow control,
and interrupt character set to CAN (^X).
.B YMODEM-g
(Professional-YAM
.B g
option)
increases throughput over error free channels
(direct connection, X.PC, etc.)
by not acknowledging each transmitted sector.

On
.SM Unix
systems, additional information about the file is transmitted.
If the receiving program uses this information,
the transmitted file length controls the exact number of bytes written to
the output dataset,
and the modify time and file mode
are set accordingly.


.B Sx
sends a single
.I file
with
.B XMODEM
or
.B XMODEM-1k
protocol
(sometimes incorrectly called "ymodem").
The user must supply the file name to both sending and receiving programs.

Iff
.B sz
is invoked with $SHELL set and iff that variable contains the
string
.I "rsh"
or
.I "rksh"
(restricted shell),
.B sz
operates in restricted mode.
Restricted mode restricts pathnames to the current directory and
PUBDIR (usually /usr/spool/uucppublic) and/or subdirectories
thereof.


The fourth form sends a single COMMAND to a ZMODEM receiver for execution.
.B Sz
exits with the COMMAND return value.
If COMMAND includes spaces or characters special to the shell,
it must be quoted.


The fifth form sends a single COMMAND to a ZMODEM receiver for execution.
.B Sz
exits as soon as the receiver has correctly received the command,
before it is executed.


The sixth form (sz -TT)
attempts to output all 256 code combinations to the terminal.
In you are having difficulty sending files,
this command lets you see which character codes are being
eaten by the operating system.


If
.B sz
is invoked with stdout and stderr to different datasets,
Verbose is set to 2, causing frame by frame progress reports
to stderr.
This may be disabled with the
.B q
option.
.PP
The meanings of the available options are:
.PP
.PD 0
.TP
.B +
Instruct the receiver to append transmitted data to an existing file
(ZMODEM only).
.TP
.B 1
Use file descriptor 1 for ioctls and reads.
By default, file descriptor 0 is used.
This option allows
.B sz
to be used with the
.I Professional-YAM
$
command.
This also works with some versions of ncu(1), but not cu(1).
.TP
.B a
Convert NL characters in the transmitted file to CR/LF.
This is done by the sender for XMODEM and YMODEM, by the receiver
for ZMODEM.
.TP
.B b
(ZMODEM) Binary override: transfer file without any translation.
.TP
.B "c COMMAND"
Send COMMAND to the receiver for execution, return with COMMAND\'s exit status.
.TP
.B d
Change all instances of "." to "/" in the transmitted pathname.
Thus, C.omenB0000 (which is unacceptable to MSDOS or CP/M)
is transmitted as C/omenB0000.
If the resultant filename has more than 8 characters in the stem,
a "." is inserted to allow a total of eleven.
.TP
.B e
Escape all control characters;
normally XON, XOFF, DLE, CR-@-CR, and Ctrl-X are escaped.
.TP
.B f
Send Full pathname.
Normally directory prefixes are stripped from the transmitted
filename.
.TP
.B "i COMMAND"
Send COMMAND to the receiver for execution, return Immediately
upon the receiving program's successful recption of the command.
.TP
.B k
(XMODEM/YMODEM) Send files using 1024 byte blocks
rather than the default 128 byte blocks.
1024 byte packets speed file transfers at high bit rates.
(ZMODEM streams the data for the best possible throughput.)
.TP
.B "L N"
Use ZMODEM sub-packets of length N.
A larger N (32 <= N <= 1024) gives slightly higher throughput,
a smaller N speeds error recovery.
The default is 128 below 300 baud, 256 above 300 baud, or 1024 above 2400 baud.
.TP
.B "l N"
Wait for the receiver to acknowledge correct data every
.B N
(32 <= N <= 1024)
characters.
This may be used to avoid network overrun when XOFF flow control is lacking.
.TP
.B n
(ZMODEM) Send each file if
destination file does not exist.
Overwrite destination file if
source file is newer than the destination file.
.TP
.B N
(ZMODEM) Send each file if
destination file does not exist.
Overwrite destination file if
source file is newer or longer than the destination file.
.TP
.B o
(ZMODEM) Disable automatic selection of 32 bit CRC.
.TP
.B p
(ZMODEM) Protect existing destination files by skipping transfer if the
destination file exists.
.TP
.B q
Quiet suppresses verbosity.
.TP
.B r
(ZMODEM) Resume interrupted file transfer.
If the source file is longer than the destination file,
the transfer commences at the offset in the source file that equals
the length of the destination file.
.TP
.B "t tim"
Change timeout to
.I tim
tenths of seconds.
.TP
.B u
Unlink the file after successful transmission.
.TP
.B "w N"
Limit the transmit window size to N bytes (ZMODEM).
.TP
.B v
Verbose
causes a list of file
names to be appended to
/tmp/szlog .
More v's generate more output.
.TP
.B y
Instruct a ZMODEM receiving program to overwrite any existing file
with the same name.
.TP
.B Y
Instruct a ZMODEM receiving program to overwrite any existing file
with the same name,
and to skip any source files that do have a file with the same
pathname on the destination system.
.PD
.SH EXAMPLES
.ne 7
.B "ZMODEM File Transfer"
.br
.B "$ sz \-a *.c"
.br
This single command transfers all .c files in the current Unix directory
with conversion
.RB ( \-a )
to end of line conventions appropriate to the receiving environment.
With ZMODEM AutoDownload enabled, Professional-YAM  and ZCOMM
will automatically recieve
the files after performing a security check.

.br
.B "$ sz \-Yan *.c *.h"
.br
Send only the .c and .h files that exist on both systems,
and are newer on the sending system than the
corresponding version on the receiving system, converting Unix to
DOS text format.

.B "ZMODEM Command Download"
.br
 cpszall:all
    sz \-c "c:;cd /yam/dist"
    sz \-ya $(YD)/*.me
    sz \-yqb y*.exe
    sz \-c "cd /yam"
    sz \-i "!insms"
.br
This Makefile fragment uses
.B sz
to issue commands to Professional-YAM to change current disk and directory.
Next,
.B sz
transfers the
.I .me
files from the $YD directory, commanding the receiver to overwrite the old files
and to convert from Unix end of line conventions to PC-DOS conventions.
The third line transfers some
.I .exe
files.
The fourth and fifth lines command Pro-YAM to
change directory and execute a PC-DOS batch file
.I insms .
Since the batch file takes considerable time, the
.B "\-i"
form is used to allow
.B sz
to exit immediately.

.B "XMODEM File Transfer"
(To Crosstalk)
.br
$
.B "sx \-a foo.c"
.br
.B "ESC"
.br
.B "rx foo.c"
.br
The above three commands transfer a single file
from Unix to a PC and Crosstalk with
.I sz
translating Unix newlines to DOS CR/LF.
This combination is much slower than ZMODEM.
.SH ERROR MESSAGES
"Caught signal 99"
indicates the program was not properly compiled,
refer to "bibi(99)" in rbsb.c for details.
.SH SEE ALSO
rz(omen),
ZMODEM.DOC,
YMODEM.DOC,
Professional-YAM,
IMP(CP/M),
sq(omen),
todos(omen),
tocpm(omen),
tomac(omen),
yam(omen)

Compile time options required for various operating systems are described in
the source file.
.SH "VMS VERSION"
The VMS version does not transmit the file date.
The VMS version calculates the file length by reading the file
and counting the bytes.

The VMS version does not support YMODEM-g or ZMODEM.

When VMS is lightly loaded, the response time may be too quick for MODEM7
unless the MODEM7
.B "q"
modifier is used.

The VMS C standard i/o package and RMS sometimes interact to modify
file contents unexpectedly.
.SH FILES
32 bit CRC code courtesy Gary S. Brown.

sz.c, rbsb.c, zm.c, zmodem.h source files

/tmp/szlog stores debugging output (sz -vv)
.SH "TESTING FEATURE"
The command "sz -T file"
exercises the
.B Attn
sequence error recovery by commanding
errors with unterminated packets.
The receiving program should complain five times about
binary data packets being too long.
Each time
.B sz
is interrupted,
it should send a ZDATA header followed by another defective packet.
If the receiver does not detect five long data packets,
the
.B Attn
sequence is not interrupting the sender, and the
.B Myattn
string in
.B sz.c
must be modified.

After 5 packets,
.B sz
stops the "transfer" and
prints the total number of characters "sent" (Tcount).
The difference between Tcount and 5120 represents the number of characters
stored in various buffers when the Attn sequence is generated.
.SH BUGS
Calling
.I sz
from most versions of cu(1) doesn't work because cu's receive process
fights
.I sz
for characters from the modem.

Programs that do not properly implement the specified file transfer protocol
may cause
.I sz
to "hang" the port for a minute or two.
Every reported instance of this problem has been corrected by using
ZCOMM, Pro-YAM, or other program with a correct implementation
of the specified protocol.

Many programs claiming to support YMODEM only support XMODEM with 1k blocks,
and they often don't get that quite right.

XMODEM transfers add up to 127 garbage bytes per file.
XMODEM-1k and YMODEM-1k transfers use 128 byte blocks
to avoid extra padding.

YMODEM programs use the file length transmitted at the beginning of the
transfer to prune the file to the correct length; this may cause problems with
source files that grow during the course of the transfer.
This problem does not pertain to ZMODEM transfers, which preserve the exact
file length unconditionally.

Most ZMODEM options are merely passed to the receiving program;
some do not implement all these options.

Circular buffering and a ZMODEM sliding window should be used
when input is from pipes instead of acknowledging frames each 1024 bytes.
If no files can be opened,
.B sz
sends a ZMODEM command to echo a suitable complaint;
perhaps it should check for the presence of at least one accessible file before
getting hot and bothered.
The test mode leaves a zero length file on the receiving system.

A few high speed modems have a firmware bug that drops characters when the
direction of high speed transmissson is reversed.
The environment variable ZNULLS may be used to specify the number of nulls to
send before a ZDATA frame.
Values of 101 for a 4.77 mHz PC and 124 for an AT are typical.
\Rogue\Monster\
else
  echo "will not over write ./sz.1"
fi
if [ `wc -c ./sz.1 | awk '{printf $1}'` -ne 12352 ]
then
echo `wc -c ./sz.1 | awk '{print "Got " $1 ", Expected " 12352}'`
fi
if `test ! -s ./gz`
then
echo "Writing ./gz"
cat > ./gz << '\Rogue\Monster\'
exec sz -c "sz $*"
\Rogue\Monster\
else
  echo "will not over write ./gz"
fi
if [ `wc -c ./gz | awk '{printf $1}'` -ne 19 ]
then
echo `wc -c ./gz | awk '{print "Got " $1 ", Expected " 19}'`
fi
if `test ! -s ./ptest.sh`
then
echo "Writing ./ptest.sh"
cat > ./ptest.sh << '\Rogue\Monster\'
#a short test for sz and rz using a named pipe - no modem used.
/etc/mknod fifo p
sz <fifo /etc/motd |rz >fifo
rm fifo
\Rogue\Monster\
else
  echo "will not over write ./ptest.sh"
fi
if [ `wc -c ./ptest.sh | awk '{printf $1}'` -ne 119 ]
then
echo `wc -c ./ptest.sh | awk '{print "Got " $1 ", Expected " 119}'`
fi
if `test ! -s ./zupl.t`
then
echo "Writing ./zupl.t"
cat > ./zupl.t << '\Rogue\Monster\'
	:: ProYAM/ZCOMM script to upload minirb and rz/sz to *nix
	if S>1200 pt1
	ena -t
	if !fminirb.c echo "Can't find minirb.c !!";  abort
	putw "stty -echo; cat >minirb.c\r"
	f -xHr minirb.c
	putw "\r\4"
	putw "stty echo\r"
	dis -h
	pat 1 "rwx"
	pat 2 "%"
	put "cc minirb.c -o minirb; ls -l minirb\r"
	wait -f120
	if 1 goto okok
	echo "The compiiation appears to have failed."
	echo "Please compile minirb.c to minirb, then"
	echo "hit F5 to upload the rest of the rz/sz files."
	set f5
@putw minirb\r; sb README zmodem.h zm.c sz.c rz.c rbsb.c *.1 gz ptest.sh
	t
	return
okok:	echo "Minirb Compilation Appears Successful."
	put minirb\r
	sb README zmodem.h zm.c sz.c rz.c rbsb.c *.1 gz ptest.sh
	t
	return
\Rogue\Monster\
else
  echo "will not over write ./zupl.t"
fi
if [ `wc -c ./zupl.t | awk '{printf $1}'` -ne 703 ]
then
echo `wc -c ./zupl.t | awk '{print "Got " $1 ", Expected " 703}'`
fi
echo "Finished archive 1 of 3"
exit

