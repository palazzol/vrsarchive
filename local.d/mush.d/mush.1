.\" Mush Man Page: Copyright (c) 1987 Dan Heller
.\"
.TH MUSH 1 "Mar 3, 1987"
.UC 4
.SH NAME
The Mail User's Shell \- Shell for electronic mail.
.SH SYNOPSIS
.B mush
[
.B \-S
]
[
.B \-C
]
[
.B \-f
[
folder
]
]
[
.B \-n
]
[
.B \-T
timeout
]
[
.B \-t
]
[
.B \-i
]
[
.B \-N
]
[
.B \-H[:c]
]
[
.B \-r
]
[
.B \-v
]
[
.B \-s
subject
]
[
.B \-c
cc-list
]
[
.B \-1
cmd_help
]
[
.B \-2
tool_help
]
[
.B \-d
]
[
user list ...
]
.SH INTRODUCTION
The Mail User's Shell (Mush) is an interface for sending and manipulating
a database of electronic mail messages under the
.I UNIX
environment.  There are three user interfaces which allow the user to
interact with
.I Mush.
The
.I window
interface for the Sun Workstation utilizes the icon and
menu based (mouse selectable) windowing system. This
.I tool
(graphics), mode is highly subject to the version of operating system
your Sun may be running.  While the program works with variable levels
of success on earlier versions, it is intended to be run on Sun versions
2.0 and higher. See the BUGS section at the end for more information.
.PP
The text-graphics interface is reminiscent of the
.I vi
visual editor. This interface does not require graphics capabilities of
the computer or the terminal on which it is run, but the terminal must
have the minimum capabilities required by any visual screen editor.
.PP
The default interface is the conventional tty-based line mode
similar to command line interpreters such as
.I csh
as well as other mailers, such as University of California, Berkeley's,
.I Mail
and Bell Lab's System V
.I mailx
interface.  This mode requires nothing from the terminal in cursor
optimization and may be run on many different version of
.I UNIX
running on various architectures such as VAX and MicroVax (4.2, 4.3 BSD),
IBM-PC AT's running system V (XENIX), IBM-RT's, and pyramids.
.PP
See the correpsonding subheadings for more information on the user
interface desired.  Most of this manual deals with commands, variables
and actions which are usually common to all three interfaces although
some attention is paid to individual characteristics of each interface.
.PP
The following command line arguments are understood by
.I Mush:
.TP
\-S
This flag allows the user to enter the shell even if the system
mailbox, or specified folder is empty or doesn't exist.
.TP
\-C
Enter the mailer in curses mode upon startup.
.TP
\-f [ filename ]
The optional filename argument specifies a folder containing mail messages.
With no argument,
.B mbox
in the current directory (or the variable `mbox')
is used.
.TP
\-n
No initialization is done on start up.  That is, do not source
.I .mushrc
or
.I .mailrc
files.
See the subheading INITIALIZATION for more inforation on start and these files.
.TP
\-T timeout
(Sun only) In the tool mode,
.I timeout
specifies the length of time (seconds) to wait between each check for new mail.
30 seconds is the smallest time allowed for performance reasons. 60 seconds
is the default value.
.TP
\-t
Use the graphics tool mode (Sun only).
.TP
\-i
Forces interactive mode even if input has been redirected to the program.
This is intended for remote host mail sessions but also allows
the user to redirect "scripts" of
.I Mush
commands.  See the INITIALIZATION subheading for information on how to
write scripts which deal with mail.
.TP
\-N
Enter
.I Mush
without displaying any message headers. This argument is passed to the
.B folder
command.
.TP
\-H[:c]
Have
.I Mush
just display mail headers without entering the shell.
See the
.B headers
command for information on the
.B :c
argument. No colon modifier is equivalent to
.B "-H:a.\ "
This option prevents the shell from running, so this option will turn off the
flags, -S and -C.  This option is ignored if the tool mode is in effect.
.TP
\-r
Initialize the folder in Read-Only mode; no modification of the folder is
permitted. This argument is passed on to the
.B folder
command.
.TP
\-v
Verbose mode is turned on. This option is passed to the actual mail delivery
subsystem internal to your version of
.I UNIX.
Some mailers do not have a verbose option, so this flag may not apply
to your system (System V, for example).
This applies when sending mail only.  If you are entering the shell,
curses mode, or the tool mode, this option is ignored.
.TP
\-s subject
The subject is set on the command line using this flag. If the subject has
any spaces or tabs, the entire subject should be encased in quotes.
This applies when sending mail only.  If you are entering the shell,
curses mode, or the tool mode, this option is ignored.
.TP
\-c cc-list
he list of Carbon Copy recipients is set on the command line. If more than
one address is specified, the entire list should be encased in quotes.
This applies when sending mail only.  If you are entering the shell,
curses mode, or the tool mode, this option is ignored.
.TP
\-1 cmd_help
.TP
\-2 tool_help
Specify alternate locations of help files.  These should be full pathnames
accessible for reading.  This is usually done if a binary copy of
.I Mush
has been copied from another machine and the wrong pathnames to the
help files cannot be changed.
.TP
\-d
Turns on the debugging level to 1.  You can change debugging levels from
within the shell using the
.B debug
command.
.SH FEATURES
.PP
The following features are common to all user interfaces that
.I Mush
provides.  Interface-specific features are listed separately
under the subheading for that interface. Commands and user definable
variables are described under the appropriate subheadings.
.PP
.B New Mail.
.PP
If during a
.I Mush
session, new mail arrives for you, it is automatically incorporated into
your system mailbox and you are told that new mail has arrived.
.PP
In the default line mode, new mail is checked between each command
issued. In the tool based graphics mode, new mail is checked approximately
every minute or by the number of seconds specified by the
.B -T
option on the command line. In the curses mode, new mail is checked on each
command and is displayed in the bottom line of the screen.
.PP
If you are using your system mailbox as your "current folder," then the
new mail is added immediately to your current
list of messages and this information is displayed telling you whom the mail
is from:
.sp
.ti +5
New mail: (#15) island!argv@Sun.Com
.sp
If you are not in your system mailbox, then the new mail will not be added
to your list of messages, but you will instead be informed of the new arrival.
.sp
If you are using the tool based mode and
.I Mush
is closed to an iconic state, then the number of messages in the current
folder is displayed on the mailbox icon and the flag on the mailbox will go up.
.sp
.PP
.B Aliases.
.PP
Mail aliases are shorthand names for long mail addresses.  These are
supported in the same manner as UCB Mail supports them.  Because
.I Mush
has command line history reminiscent of
.I csh,
commands which use uucp's `!' character for user-host and host-host
separation should be escaped (preceded by a backslash).  This is not
necessary in the initialization file (.mushrc) because history
referencing is ignored while these files are being sourced.  See the
subheading, INITIALIZATION and the line-mode interface for more information
on initialization file format and the history mechanism.
.sp
Aliases reference normal mailing addresses as well as other aliases. If a loop
is detected, then the user will be notified and a dead.letter will be
forced into the file
.B dead.letter
in the user's home directory.  The command,
.B unalias,
is used to reverse the effects of the
.B alias
command.
.sp
.PP
.B Help.
.PP
.I Mush
was designed so that each command or action should not be a mystery.
Helping the user understand what to do and how to do whatever he wishes
is the goal behind the help facility. For this reason, the command,
.B help
gives information on both general usage and specific help categories.
.PP
In text mode, most help is gotten by typing `-?' as an argument to a
command.  Virtually all commands have the -? option.  When this option
is specified, most commands will attempt to read from a help file the
necessary information explaining the functionality of the command in
executed. If necessary, a pointer to other sources of information will
be given to fully explain a concept.
.PP
In the tool/graphics mode, this is
also possible, but more extensive help is provided in the pop-up menus.
Pop-up menus can be gotten from virtually anywhere on the screen; press the
RIGHT mouse button (the "menu button") and a number of items will appear
in a menu. The last command in the menu list will be one labelled "help."
Selecting this menu item will display a "help box" in the center of the
console and wait for input to remove the box.
.PP
In the curses mode, the `?' key will display a list of the current
command-to-key bindings; a keystroke or set of keystrokes correspond
directly to a command.
.PP
.B Sorting mail.
.PP
.I Mush
allows you to sort your mail according to various constraints such
as time, status (new, unread, deleted, etc), by author and subject.
See the
.B sort
command in the subheading COMMANDS for more information on sorting.
.PP
.B Picking specific messages.
.PP
You can select messages that contain unique information, or from
messages that have special attributes.  You have the option of
restricting your search to messages between dates, message numbers,
author names and other constraints.
.sp
.SH INITIALIZATION
.PP
Upon startup, before any command line arguments are parsed, and before
the current folder's messages are read (thus, there are no messages to
speak of, yet),
.I Mush
will initialize itself with basic variable settings and values.
If the -n option is given, initialization is
.B not
done.  If no -n option is given, it will source an
.B initializing file
which contains commands that [typically] set variable values, aliases,
command line aliases, and so forth.  The file it reads from is determined
by first looking for the environment variable,
.I MAILRC.
If that file isn't found, then the file
.I .mushrc
is search from the home directory of the user.  If that file cannot be found,
it will attempt to read the file,
.I .mailrc
from the same directory. If that file isn't found, then the default
initialization file setup by the administrator is attempted.
Finally, if that file cannot be read, then nothing is done about initialization
and the default values will be in effect.
.sp
If the user has no home directory, or permissions prevent read/write access
to $HOME, /tmp is used as the home directory. See the
.B home
variable under the VARIABLES heading.
.sp
You may specify a filename to source if you want to source a specific file
other than the default.  You may use the command
.B saveopts
to save all variable settings, aliases, and all other
.I Mush
settable attributes.  If no filename is given on the command line,
.B saveopts
chooses a file in the same manner that
.B source
does. Using saveopts is highly discouraged since it overwrites files
without warning and saves settable variables only.  ``if'' expressions
are not saved and session-dependent settings may be invalid upon next
invocation.
.PP
.I "Initialization File Format.\ "
When reading the initialization file,
.I Mush
will recognize the `#' character as a comment character.  It may
be anywhere on a line in the file.  When that character is encountered,
processing of that line is discontinued to the end of the line.
If the `#' is encased in quotes (single or double), then it is not
considered a comment.
.sp
.ti +2
set shell = /bin/csh  # set the shell variable
.ti +2
# this entire line has been commented out.
.in +2
set prompt = "Message #%m: "  # The `#' is within quotes
.sp
.PP
The
.B exit
command has special meaning in the initialization file. If the command
is found,
.I Mush
will not exit, but rather, discontinue reading from the file immediately.
.PP
There may be ``if'' expressions within the initialization file to determine
certain runtime states of
.I Mush.
There are no parentheses allowed and only one boolean expression may be
evaluated per line; that is, no ``&&'' or ``||'' may be used in expressions.
There is currently no support for multiple levels of if-else expressions
and embedded ``if'' expressions are ignored (they are evaluated to TRUE).
There must always be an ``endif'' accompanying all ``if'' expressions.
The statements associated with an ``if'' expression are never on the same
line with the conditional.
.PP
Understood conditional expressions include the internal variables,
.I istool, iscurses, hdrs_only,
and
.I redirect.
If
.I istool
is true, the program is going to start in the tool mode. If
.I iscurses
is true, the program is in or is going to start in the curses mode even
though the screen package may not have already been started. If
.I hdrs_only
is true, then the -H flag on the command line has been given. If
.I redirect
is true, then input to the program is redirected.  The
.B -i
option on the command line is required to run the shell if redirect is on.
If the flag is specified, the value for
.I redirect
will be set to false.
These are internal variables whose values can not be referenced using the
``$variable'' method of variable expansion.
.PP
The `!' operator may be used to negate expressions, thus,
.sp
.in +2
.nf
if !istool
    exit
else
    set autoprint
endif
.in -2
.fi
.sp
means that if you are not running as a tool, stop reading commands from this
file.  Otherwise, set the autoprint variable.  The test for redirection may
be done to determine whether or not input, not output, has been redirected
to the program.
.sp
.in +2
.nf
set hdr_format = "%S %25f %7d (%l/%c) %25s"
if (hdrs_only)
    exit
endif
.in -2
.fi
.sp
This tells the program to set the hdr_format variable and check to see if
we're running the program to read headers only.  If so, stop reading this
file (exit) and continue on with the program.  This speeds up runtime quite
a bit for those who have lengthy initialization files because no other shell
variables are necessary.
.sp
.in +2
.nf
if !iscurses
    set crt = 24 screen = 18
endif
.in -2
.fi
.sp
This segment checks to see if we're not running in curses mode and if not
it will set our crt and screen sizes.  This is mostly because the curses
mode will set those values for us by looking at the size of our screen
for us.  The
.B curses
command itself should never be called from an initialization file. Doing
so will cause terminal settings to be set incorrectly and unpredictable
results from there.  In fact, no interactive commands should be called
from any initialization file.  These commands are not prevented because
it is impossible to trace which commands are aliased to interactive commands
and which might even be shell commands that are interactive.  The
responsibility of not running interactive commands is left to the user.
See the section on curses under THE CURSES INTERFACE for configuring your
environment so you enter the curses interface each time you runs the shell. 
.PP
When initialization files are being read, no history expansion is done,
so the `!' need not be escaped for address aliasing.
String evaluation is allowed and the operators, "==" and "!=" may be
used to determine their equality.  Usually, variables are compared with
constants for evaluation.
.sp
.in +2
.nf
if $TERM == adm3a
    set pager = /usr/ucb/more
else
    set pager = /usr/local/less
endif
.in -2
.fi
.sp
This segment tests to see if the user's terminal type is "adm3a".  If it is,
then it sets the pager variable to be the "more" program.  Note that the
variable TERM will be gotten from the user's environment if a shell variable
is not set already.  Otherwise, the pager variable is set to "less".  This
example exemplifies the fact that "less" normally fails to function correctly
for the terminal type ``adm3a'' so we don't use it.
.PP
After sourcing the initialization file,
.I Mush
reads all the mail out of the specified folder (the system spool directory
if no folder is given) and creates a list of messages. The current maximum
number of messages the user can load is set to 1000 by default.  The system
administrator who configures the program can reset this value higher or lower
if you ask nicely. If the user has the
.B sort
variable set, then when the current folder's messages are finally read,
the messages are sorted according to the value of the
variable (see the sort entry under the VARIABLES heading for more information).
Each message has a number of message headers which contain information
about whom the mail is from, the subject of the message, the date it was
received, and other information about the letter.  This information is then
compiled into a one line summary and is printed out sequentially in the
appropriate manner depending on the interface you're using.
.PP
At this point, commands may be input by the user.  The initialization file
is read
.I before
any messages are read into the program.  Message filtering commands should
not be placed in this file unless you know you're going to resource the file
later as a command. For example, a filtering file, "filter", might contain:
.sp
.in +2
.nf
pick -f Mailer-Daemon | save mail_errors
pick -f yukko | delete
pick -s -i thesis | save +thesis_mail
pick -t unix-wizards | +wizmail
update
sort d
.in -2
.fi
.sp
The first command the user could type might be
.B source filter
and the following would happen.  First, all messages that have Mailer-Daemon
in the from line will be saved in the file "mail_errors".  Then, all mail from
the user "yukko" will simply be deleted.  Next, all mail that has in the 
subject field "thesis" (case ignored, so "Thesis" would also match) would be
saved in the file $folder/thesis.  The next command would find all messages
that were addressed to the group "unix-wizards" (of which the user is an elite
member of) and save them in the file $folder/wizmail.  The folder will be
updated, removing all deleted mail (saved mail may be marked as deleted),
and the folder is reread and sorted according to the date of the messages.
.PP
.SH THE TTY INTERFACE
In the line-mode, the user is given a prompt to which commands are issued
and arguments are passed to commands.  When the user types at the prompt,
each line is parsed and words (or, arguments) are separated into an array
of strings.  This array, also called an
.I argument vector,
is then modified by expanding history references, command line aliases,
or expanding variable references.  A command line ends when the end of
the line is encountered or a pipe (|) or semicolon (;) character are
encountered, separating discrete commands.
.PP
When a command line has been determined and placed in an argument vector, the
first argument in the vector (the `command') is searched for in a list of legal
.I Mush
commands.  If found, the function associated with that command is called and
the rest of the line is passed to that function as
.I command line arguments.
.PP
Before commands are called, however, the input the user gives is preprocessed
in a style reminiscent of
.I csh.  Mush
also supports a subset from each of the following aspects of
.I csh.
.in +2
\(bu Command history.
.br
\(bu Command line aliasing.
.br
\(bu A `piping' mechanism to redirect "input" and "output" of commands.
.in -2
.PP
.I Command history.
.PP
The history mechanism remembers commands up to the value of the
.B history
variable.  To reference previously typed commands, the `!' character
is used in the same manner as
.I csh.
.sp
Examples:
.nf
.in +2
!-2:$   two commands ago, last argument.
!3:2-4  the third command, arguments two through four.
!!      the last command in its entirety.
.sp
.in -2
.fi
There is a limited implementation of history modification.
Supported is the argument selector which references
command line arguments and 'p' (echo, but don't execute the command).
.PP
During the sourcing of initialization files (.mushrc), history is not
in effect and therefore the ``!'' character does not cause history expansion.
This includes startup of the program and when the command
.I source
is issued.  Uucp style addresses that contain the ``!'' character may
be given without the need to be preceded by a backslash in the
initialization file.  However, ``!'' does need to be escaped if
.B cmd's
are used to reference command line arguments.
.PP
.I Command line aliasing.
.PP
This feature enables command substitution similar to
.I csh.
To be backwards compatible with UCB's Mail, the
.I alias
command is used for address aliasing.  Thus, the command
.I cmd
is introduced in place of
.I alias.
.PP
Examples:
.nf
.in +2
cmd d delete
cmd t type
cmd dt 'd ; t'
cmd - previous
cmd r 'replysender \\!* -e -i'
.in -2
.fi
.sp
In the last example, if the user types `r 5',
.I Mush
will reply to sender of the fifth message and pass all the other
arguments along to the
.B reply
command.  Note the escaping of the ! character.
This must also be done if set in the initialization file (.mushrc).
Had the user not specified a message number on the command line (`r'),
.B respond
would reply to the "current message" rather than the fifth message.
.PP
.I Piping commands.
.PP
"Output" from a command is a
.B message list,
not the
.I text
in a message.  A
.B message list
is defined as the set of messages which the user specifies in a command or
the messages a command affects after it is through executing.
When one command is piped to another, the effect is that the second command
will "consider only those messages the affected by first command."
In most cases,
.I Mush
is smart enough to know when piping is occurring and may suppress text output
that a command might produce.
.PP
Examples:
.sp
.ti +2
pick -f fred | save fred_mail
.sp
This will find all the messages from "fred"
and save them all in the file named "fred_mail".
.sp
.ti +2
lpr 4-8 | delete
.sp
This will send messages 4, 5, 6, 7, and 8 to the printer and then delete them.
.sp
.ti +2
headers :o | delete
.sp
Delete's all old (already read) mail.
.PP
Because action is taken on mail messages, not files,
metacharacters such as `*' and `?' are not expanded to file names as
.I csh
would do.  Instead,
.I Mush
commands take as arguments, message lists (a list references one or
messages) to take action upon. To reference message numbers, there is a
special syntax that
.I Mush
will understand.
.sp
.in +2
.nf
.ta 2i
*	All messages.
^	The first message.
$	The last message.
.	The current message.
N-M	A range of messages between N and M.
.sp
.fi
.in -2
In the last case, N and M may be * ^ $ . or digits referencing
explicit message numbers.  The range must be in ascending order.
.sp
You can also negate messages by placing the message list inside
braces, `{' `}' -- thus, the expression "2-19 {11-14}" references
messages 2 through 19 except for those between 11 through 14.
.sp
Note that message lists are parsed left to right.  Indicating negated
messages may be reset by turning them on again later in the argument list.
A common error new users have is to specify a negated list without
specifying any beginning messages.
.ti +2
delete { 6 }
.sp
In this example, the user attempted to delete all messages
except for number 6.  He should have specified the * before hand.
.sp
.ti +2
preserve ^-. { 3 }
Here, the user specifies a valid message list and causes
.I mush
to preserve all messages from the beginning of the list (message 1)
to the current message excluding message 3.
.PP
As discussed, the command line is parsed and the command given is
called and the rest of the arguments on the command line are passed to it.
If no command has been found for the one given, then the variable
.B unix
is checked. If set, the command line given is attempted to be run as a regular
.I UNIX
command.
.PP
If it is not set, or if the command cannot be found in the user's PATH
environment, a message will be printed indicating that the command was
not found.
.PP
Since no `messages' are affected by
.I UNIX
commands, piping is disallowed either to or from such commands. If the
user wishes to execute
.I UNIX
commands which are to be piped to one another (or use any sort of redirection),
the command,
.B sh
is provided for such purposes.  Since
.I Mush
will parse the entire command line, caution should be taken by enclosing
quotes around questionable shell variables or metacharacters.
See the COMMANDS heading below for more detail.
.PP
This shell-like quality is for the convenience of the user and is not
intended to replace the functionality of
.I sh, csh,
or any other command interpreter.
.sp
.SH THE CURSES INTERFACE
The curses interface utilizes the curses routines intrinsic to most
UNIX systems these days.  This interface is screen oriented rather
than line oriented and allows the user to access commands and messages
more quickly at the cost of history, piping, and a few commands.
.PP
Many users who prefer the curses interface might want to always start
all their mail sessions in the curses interface.  Putting the curses
command in your initialization file is a no-no, so you can alias your
login shell mail command to include the -C option.  If you use the Bourne
Shell, you're going to have to type it out all the time.  Mush is  going
to attempt to know not to run a shell if you're just sending mail to someone,
so the command line sequences:
.sp
.nf
% alias mail 'mush -C'
% mail fred
.fi
.sp
will mail to fred and not enter the shell.  However, if you just said, "mail"
with no arguments, you'll enter the shell in curses mode if you have mail.
If you don't, you'll be told so.  If you want to enter curses mode even if
you don't have mail, use the -S option on the command line.
.PP
In curses mode, the user's terminal has it's "echo" turned off so commands
that are issued are not echoed on the screen. Certain commands cause the mode
to return to normal for typing purposes (sending mail, for example).
In normal operation, the screen will display the current set of message
headers, the current message number is in the top left corner, the
mail status on the top line, and the cursor will be placed on the current
message. The number of message headers displayed is set by the variable,
.B screen.
If the user does not have that variable set, the baud rate is checked and
the size of the screen is set according to optimal refresh time. Usually,
300 baud gives 7 lines, 1200 gives 14, 2400 gives 22 lines, and all higher
baud rates give the size of the screen, whatever that may be.
Note that the top line is reserved for "status" and the bottom line is
for user interaction should it be required.
.PP
The user may now type commands via key sequences which are not echoed
to the screen.  Thus, function keys may be bound to "commands" by using the 
.B bind
command. 
A list of key-to-command bindings can be found at runtime by typing `?'
in curses mode or by using the
.B bind
command.
.PP
The commands which you can map sequences to are intended to be as self
explanatory as possible, but admittedly, it's easier to figure out via
trial and error than to try to wade through this documentation.
A list of the legal curses commands can be obtained when executing the
bind command.  Regular tty line-mode commands are not issued from
the curses interface; only special curses mode commands are understood.
The current list of valid curses commands is:
.sp
.ta 1.5i 3i 4.5i
.in +4
.nf
goto msg	write	write list	save
save list	copy	copy list	delete
delete list	undelete	undelete list	reverse video
redraw	next msg	back msg	first msg
last msg	top page	bottom page	screen next
screen back	show hdr	source	saveopts
search up	search down	search cont	preserve
sort	sort reverse	quit!	quit
exit!	exit	update	folder
shell escape	line mode	lpr	chdir
variable	ignore	alias	my hdrs
version	mail flags	mail	reply
reply all	display	top	display next
bind	unbind	help 
.fi
.in -4
.sp
.PP
The following is a list of default key-command bindings.  If you specify
bind commands in your initialization file that conflict with these defaults,
your settings will override the defaults.  The default settings given here
use the ^-character method to indicate control characters.
Thus, `^X' would mean control-X even though you'd have to type "\\CX" to set
the binding and actually use the control key and the `X' key simultaneously
to really
.I do
a Control-X.  This is mostly because nroff makes printing the backslash
character so amazingly difficult.
.TP
t, p, T=top, n=next
Display (type/print) message. Top will display the first
.B crt
lines of a message. `n' will print the next message.
If the current message is deleted, the next undeleted message is found.
You might notice this is different than the line mode which will return
an error message that the current message is marked as deleted.
.TP
+, j, RETURN
Go to next message.
.TP
-, k, ^K
Go to previous message.
.TP
z, Z
Print next/previous screenful of messages.
.TP
H
Header information for the current is printed.  This only works when
the user is provided with the "...continue..." prompt and he wishes to
view the current message header instead of redrawing the entire screen.
.TP
f
change folder. If current folder has changed, verification for update
will be prompted.
.TP
^U
update folder.
.TP
v
set regular variables.
.TP
a
set aliases
.TP
h
set personal headers
.TP
i
set ignored headers
.TP
|
send message to printer
.TP
m, M
send mail (prompt for mail flags).
.TP
d, D, u U
delete/undelete messages (prompt for message list).
.TP
^P
Preserve current message (toggle).
.TP
r, R
reply sender/reply all.
.TP
s, S, c, C, w, W
save, copy, or write messages (capitals prompt for message lists).
.TP
!
Shell Escape --prompts for command: RETURN invokes a shell.
.TP
o, O
Order messages (sort).  O reverses order.  The order in which to
sort messages is prompted.
.TP
(, )
source/saveopts --filename is prompted.
.TP
/, ^/ ^N
forward, backward, continue search for patterns.  Entire messages are
not searched for here.  Only the text available on the screen is searched for.
.TP
V
Print version number.
.TP
{, }
Top/bottom of screen.
.TP
^, $
Go to first/last message.
.TP
%
change directory.
.TP
g, 0-9
Go directly to message number.
.TP
:[cmd]
Enter line mode for one command (RETURN exits curses-mode).
.TP
Q, q, X, x
Quit. `x' does not update mail. `Q' does not prompt for update verification.
`Q' and `X' may be typed at the "...continue..." prompt whereas `q' and `x'
may not.
.TP
^R
Toggle reverse video mode (current message is in reverse video).
.TP
^L
redraw the screen.
.PP
When setting new key sequences to be bound to commands, the user may
use control keys and the ESCAPE character for extended commands.
Exceptions are control-C, control-\\, and possibly other control characters
depending on your system's configuration or your current tty interrupt
character settings.  The spacebar may not be bound since
it is the only obvious way to return to the top level curses mode from the
"...continue..." prompt.
.PP
When assigning key sequences to commands, the user enters the
.B bind
command and prompting is done.  If the
user wishes to have control characters or the escape character in a key
sequence, he must use special notation since control characters are not
echoed visibly on the screen.  This same sequence is used if the user wants
to bind sequences in the initialization file.
.PP
To bind control characters, the sequence, "\\Cc" is used where ``c'' is the
character which the control key will translate to and must be in upper case.
The sequence, "\\CP" would map
to control-P.  If the user wishes to indicate the RETURN key, this is specified
with the string, "\\n" and the tab key is specified by the string "\\t".
On a Wyse-50 terminal, the 8th function key outputs the three characters:
Control-A, H, line-feed.  To map this function key to a command, the
user would have to enter the sequence, "\\CAH\\n" as the key sequence,
then follow up with a valid curses command.  From then on, if the user
uses that function key, then the command mapped to it will be executed.
.PP
The ESCAPE key is signified by the sequence, "\\E".  On a Sun-3 workstation,
the R1 key outputs the character sequence: ESC, [, 2, 0, 8, z.
The corresponding key sequence would be "\\E[208z".
Restrictions are that key sequences may not contain the space key
or begin with a digit.  Unfortunately, this makes mapping the spacebar
to a command impossible.
.PP
Whenever a command is entered, if the command causes
the screen to scroll or be refreshed in anyway, the mode is left in the
.I continue
mode.  When in this mode, the user is given his line-mode prompt followed
by "...continue..." indicating that he may issue a new command or
return to the top level where the current message headers are displayed
on the screen. Remember that this is still the curses mode, but much time
is saved by avoiding to redraw the screen after each command.  The user
may move up and down messages using the appropriate commands (j/k by default)
or anything else the curses mode allows.  Unknown commands do not return to
the top level, only the spacebar, and the exit and quit commands will return
to the top level.
Because the exit and quit commands are used to do this, there are 2 additional
ways to "quit" in the program and return to the login shell.
The two commands, "exit" and "quit" commands will quit from the top level, but
the commands,
.B exit!
and 
.B quit!
are used to exit from the "continue" level in the curses interface as well
as from the top level.
.PP
Note that the best way to understand the curses interface is to just use it.
In line mode, the command "curses" puts you into curses mode.
.PP
.SH THE GRAPHICS INTERFACE
When running the window-based graphics interface, there will be 5
windows displaying panels of commands, message headers and a text
window which is used for displaying messages or writing messages
to send to other users.
.PP
The panel items have labels describing their functionality.  Selecting
a panel item with the LEFT mouse button causes the action to be executed.
The RIGHT mouse button displays a menu of options that the command may
branch to.  For example, the
.B save
panel item by default will save messages to the file "mbox", but if the
RIGHT mouse button causes a menu to be displayed the choices of where
to save the message increases to include the items in the menu.  These
typically include the files in the user's folder directory (see the
.B folder
variable below).
.PP
At the end of each list of menu entries for panel items is an item
labelled "help."  When this item is chosen, help with that command
is displayed in the center of the console.
.PP
When composing letters, the interface is the same for the tool mode,
the line mode and the curses mode.  Tilde escapes are recognized by all
the interfaces, but the tool interface allows the user to use the menu
mouse button to select the tilde escape desired.
.PP
If the user wishes to review a mail message while in edit-mode, he may
do as the other interfaces and enter the tilde escape command, ``~:print''.
This will cause the current message (or message number if given) to be
displayed in the window.  Editing is temporarily put on hold till the user
enters a `q' in the message window to indicate that he is done reading the
message and input is to be directed again to the letter being composed.
.PP
.SH GENERAL USAGE
.PP
Because there are three different interfaces available to the user,
the tty characteristics (backspace, kill-word, kill-line, redraw line)
are simulated identically to all routines. When the user has to type
something, the 4.2BSD style of tty driver interface is simulated whether
you're in the window system, the curses mode, the tty-line mode, and
even on System-V machines. This means that backspacing causes a
backspace-space-backspace effect (erasing the character backspaced over).
The user may reset his tty characteristics using the stty command.
.PP
.I "Displaying messages.\ "
.PP
Depending on the interface you use, you can display any message in your
list of messages as long as the message is not marked for deletion.  If
the message is marked as deleted, then use the 
.B undelete
command supplied by the interface you are using.
To display a message in line mode, specify a message to be displayed using
.B print, type, p, t,
or by typing the message number, that message will be printed on the screen.
.sp
In the graphics mode, you move the mouse over the message you wish to
be displayed and select the LEFT mouse button.  If the message you want
is not visible (in the header subwindow), you may type in the message
subwindow the number of the message and hit return.  That message number
will be displayed.
.sp
In curses mode, you can move the cursor over the message you want and type
a `t' or `p' to read the message.  The user may "bind" other keys to call
the function which displays messages if `t' or `p' are uncomfortable.
.sp
In the line or curses mode, if the message has more lines than the variable
.B crt,
then a
.I pager
will be invoked to allow the user to page through the message without
having it race by the screen.  The pager used is determined by the variable,
.B pager.
If that variable is unset, the a default pager will be used.  Note that
if pager is set, but not to a value, then nothing will be printed.
.PP
In the tool mode, if a message is larger than the size of the message
subwindow, the amount of the message viewed is displayed and the user
may page through the message via `+' (forward by lines), `-' (backwards
by lines), LEFT mouse button (forward by pages), or RIGHT mouse button
(backwards by pages).  The user may precede the `+' and the `-' keystrokes
with a numerical
.I count
to specify how many lines to scroll.
.PP
An alternative to displaying messages is the
.B top
command.  This command will print just the top few lines of a message.
The number of lines is determined by the variable,
.B toplines.
If this variable isn't set, ``top'' will print the value of the variable,
.B crt,
number of lines.
.sp
.PP
.I "Sending mail.\ "
You can send mail using the
.B mail
command or by responding to other mail. In either case, when you are
sending mail, you are in a mode where everything you type is added to
the contents of the message.  When you are done typing your message, you
can type ^D to signify the end of the message.  If you have the variable,
.B dot
set, then you can end a message with a "." on a line by itself.
.PP
While you are composing a message,
.I Mush
treats lines beginning with the character `~' specially.
This is called a
.B tilde escape.
For instance, typing ``~i'' (alone on a line) will place a copy
of the "current message" into your message body.  It will not include
the message headers of the message, just the body of text. Each line of
the message will be preceded by "> " to indicate that it is an included
message.  You can set the variable string
.B indent_str
to a string if you want to precede those lines with
something other than "> ".
.sp
Available
.I tilde escapes:
[OPTIONAL arguments in square brackets]
.TP
~e [editor]
Enter the editor. `set editor', env EDITOR, vi.
.TP
~v [editor]
Enter the visual editor. `set visual', env VISUAL, vi.
.TP
~p [pager]
Page the message body. `set pager', env PAGER, more.
.TP
~i [msg#'s]
Include current msg body [msg#'s] indented by indent_str.
.TP
~H [msg#'s]
Same, but include the message headers from included messages.
.TP
~f [msg#'s]
Forward mail. Not indented, but marked as "forwarded mail".
.TP
~t [list]
Change list of recipients. If a list is given, this list is
.B appended
to the current list.  If no list is given, then the current list
is displayed and the cursor placed at the end of the list.  You
can backspace over the stuff in the list or you can append more
addresses onto the end of the list as desired.  System-v users
may only replace the line, retyping it if necessary, to append new
users; specifying a list on the tilde line is recommended in this case.
.TP
~s [subject]
Modify the subject header. If an argument is given (a new subject), then
the subject line is
.B replaced
by the new subject line.  If none is given, then the subject line is
displayed for editing just as the ~t command.
.TP
~c [cc list]
Modify carbon copy recipients identical to ~t.
.TP
~b [bcc list]
Modify blind carbon recipients identical to ~t.
.TP
~h
Modify all message headers.  Each header is displayed one by one and
each may be edited.
.TP
~S[!]
Include Signature file [don't include] at end of message. The variable,
.B autosign
describes the file or string to append to the message.
See the VARIABLES section for more information on this variable.
.TP
~F[!]
Add a fortune at end of letter [don't add] at end of message.
.TP
~w file
Write message buffer to file name.
.TP
~a file
Append message buffer to file name.
.TP
~r file
Read filename into message buffer.
.TP
~q
Quit message; save in dead.letter if "nosave" is not set.
.TP
~x
Exit message; don't save in dead.letter.
.TP
~$variable
Insert the string value for variable into message.  If a boolean variable
is listed, nothing is appended regardless of its value.
.TP
~:cmd
Run the
.I Mush
command ``cmd''.  You may not run any form of reply or sending of
mail at all.  It is inadvisable to change folders at this time
since the current message list may be corrupted, but the action is
allowed nonetheless providing flexibility for experienced users.
.TP
~u
Up one line.  If the user made a mistake typing a letter and he
has already hit carriage return, he may avoid entering the editor
and edit the previous line using ~u.  The line is retyped and
the cursor is placed at the end allowing the user to backspace
over it and retype the line.  System V users should note that if
the new line is shorter than is was previous to the ~u command, the
line is padded with blanks to the previous length of the file.
.TP
~E
Erase message buffer; clear all contents of letter.
.TP
~~
A line beginning with two escape characters will be unaffected by
.I Mush
except that only a single tilde will be inserted into the letter.
.sp
The variable
.B escape
may be set to describe a character other than ``~'' to be used as the
escape character.
When sending mail, all the above applies to all three user interfaces.
.PP
.SH COMMANDS
Described below are legal commands understood by
.I Mush
that you can type at your prompt.  Most commands have abbreviations
(given in parentheses) and can be followed by message lists.  In most cases,
whitespace is not necessary to separate commands from message lists.
For example, "d*" will delete all messages.
"u1-7 {4}" will undelete messages 1 through 7 except for message number 4.
.in -2
.PP
The ability to customize commands using the
.B cmd
facility allows users to have
.I Mush
have a command line appearance to reflect other mailers. However, there
have been efforts already made to have commands which are backwards compatible
with other line-mode mailers.  Users of the graphics tool mode of
.I Mush
may have little need for the command line mode because the icon based
interface allows interaction with many commands.  The graphics mode is much
more restrictive in favor of user friendliness but most useful commands may be
achieved anyway.
.TP
.B alternates
(\fBalts\fR) is useful if you have accounts on several machines.
It can be used to inform
.I Mush
that the listed addresses are really you. When you
.B reply
to messages,
.I Mush
will not send a copy of the message to any of the addresses
listed on the
.I alternates
list. If the
.B alternates
command is given with no argument, the current set of alternate
names is displayed.
.TP
.B cd
change the working directory to that specified, if given.  If
no directory is given, then changes to the user's home directory.
.TP
.B cmd/un_cmd
Command line aliases are set and unset using these commands. More
extensive information is given in the first section of this document.
.B uncmd
may take `*' as an argument to uncmd everything set.
.TP
.B debug [N]
Set debugging level to N (1 by default).  When in debug mode, the
user can see some of the flow of control the program makes while
executing.  The intent of the debug level is for tracking down
bugs with the program at specific locations.  Periodically, the
program will segmentation fault and core dump.  When this happens,
the user can reenter the program, set the debugging level and recreate
the problem.
.sp
If the user suspects memory allocation problems, a debugging
level of 2 or higher will prevent memory from being freed causing no
overwriting of memory bounds.
.sp
If the user suspects sendmail errors,
a debugging level of 3 or higher will prevent sendmail from starting
and outgoing mail is sent to the standard output instead of actually
being sent.
.TP
.B delete
Takes a message list as argument and marks them all as deleted.
Deleted messages will not be saved in
.IR mbox ,
nor will they be available for most other commands.
.TP
.B dt
Deletes the current message and prints the next message.
.TP
.B echo
echoes all the arguments given on the command line expanding variables
and expanding history references.
.TP
.B exit
(\fBx\fR) Effects an immediate return to the Shell without
modifying the current folder or system spool directory.
.TP
.B expand
Aliases, given as arguments, are expanded as they would be if you
were to send mail to each.
.TP
.B fkey/un_fkey
Prints the values of the function keys. The function keys are used in
the graphics tool mode only.  You can set the values of function keys
explicitly using the
.B fkey
command, but the whole process is automated by using the function key
interface provided by the graphics mode.  By default, the
last key in each function key pad displays  the values of all the function
keys in that set of function keys. There are the left, right and top set
of keys.
.TP
.B folder
(\fBfo\fR) [-N] [-r] [!] [ %[user] | # | & | file ]
.br
Change current folder.  No arguments prints current folder.
.nf
.if t .ta 1.5i
.in +2
-N	No headers are displayed upon entering new folder.
-r	read only mode (you won't be able to write changes to this folder).
!	is specified, the current folder is not updated first.
%[user]	folder to /usr/spool/mail/[user] (yours, by default)
#	folder accessed previous to current folder
&	"mbox" -- default is ~/mbox; or set mbox = "file"
.in -2
.fi
.TP
.B folders
List the names of the folders in your folder directory.
Your folder directory is the directory
.I Mail
in your home directory. Or, you can set the variable
.B folder
to specify another folder directory.
.br
.TP
.B from
(\fBf\fR) With no arguments, from will print the current message's header.
If given a message list, from will print the headers of those
messages which are in the list.
.sp
The special arguments, `-' and `+' can be given to move the
current message pointer to the previous or next message
respectively while also printing that message's header.
If a message list was given in addition to `-' or `+', then
the current message pointer will be set to the first or last
message, respectively, in the message list given.
.sp
.ti +2
pick -f Dan | from +
.sp
will print the headers of all messages that contain Dan in
in the author's name and set the current message pointer to
the last one of that kind in the list.
.sp
.ti +2
from - 10-30 {16}
.sp
will print the headers of messages 10 through 30 except for
message 16 and set the current message pointer to 10.
.sp
.ti +2
from +
.sp
will print the header of the message after the current message
and increment the current message pointer to the next message.
.sp
.ti +2
from $
.sp
will print the last message's header and not move the current
message pointer.
%%
.TP
.B headers
(\fBh, z\fR) Prints a screenful of message headers listed in the
current folder.  If a message number is given on the command line,
the first message of the screenful of messages will be
that message number. The ``z'' command is identical to the ``h''
command and remains for compatibility reasons.  The variable
.B screen
may be set to tell how many headers are in a "screen."  In the graphics
tool mode, the variable,
.B screen_win
contains the number of headers used in the headers subwindow.
.sp
A typical header may look like:
.sp
.ti +2
5 >N argv@spam.istc.sri.com Feb. 9, (10/278) Test Message.
.sp
This line indicates that it is message number 5,
.I >
indicates that the "current message pointer" is pointing to this
message, the author of this message is
.I argv@spam.istc.sri.com,
the date is
.I Feb. 9,
the number of lines in the message is
.I 10,
the number of characters is
.I 278
and the subject of the message is
.I Test Message.
The format of the message header exemplified here is described by
the string variable,
.B hdr_format.
The format style of this variable string is just like printf in C.
When printing the information, the variable is evaluated and each
character in the string is echoed unless a ``%'' character is
encountered.  If one is found, the
following string substitutions may be made:
.in +2
.nf
%S  message Status.
%f  the entire "From:" field (author).
%a  the address of the author.
%n  the name of the author.
%t  "to" field (recipients).
%d  date of the message.
%s  subject of the message.
%l  number of lines in the message.
%c  number of characters (bytes) in the message.
\\n  \ a newline
\\t  \ a tab.
.fi
.in -2
A field specifier may be used in all options.  Thus, %20f will print the
first 20 characters of the from line.  No matter what the formatting string,
the message number followed by a '>' (if current message) is printed.
.sp
The "address" and "name" of the author are extracted from the "From:"
field of the message.  The name may be given in parentheses and
the rest of the line is the address, or the address is given in angle
grackets, (``<'' and ``>'') and the rest of the line is the name. Sometimes,
the address is the only thing on the line in which case the name and address
are the same.
.sp
The example given above has a hdr_format of
.ti +2
set hdr_format = "%S %25f %7d (%l/%c) %25s"
.sp
You can print a special subset of message headers by using the
.I -H:c
option, where ``c'' is one of:
.nf
.in +2
n    just print messages headers of new messages
d    deleted messages
u    unread messages
o    old messages
a    all messages
.fi
.in -2
.sp
More options to the
.B headers
command include
.I +
and
.I -.
Each will print the next or previous screenful of message headers.
Equivalent commands include
.B z [+] [-].
``z'' alone will print the next screenful (thus, the + is optional).
The ``-'' is equivalent to ``h -''.
.sp
Headers affects all the messages it displays, so piping may be done
from the headers command.  Piping to the headers command causes the
message headers affected by the previous command to be printed. This
action would be identical to piping to the
.B from
command.
.TP
.B help
Help is provided on a per topic basis and on a general basis.
For general help, just typing,
.I help
will provide some general information as to how to get further help
and a list of topics suggested for more specific help.  There is also
help provided for each command by using the "-?" option to most commands.
This option will provide command line usage information as well as a
description of what the command does and how to use it.
.TP
.B history [-h] [-r] [#histories]
The command history is displayed in chronological order; early commands
are printed first followed by more recent commands displayed last.
.I -h
suppresses printing of history event numbers with each history command.
.br
.I -r
reverses the order of the history events displayed.
.sp
If a number of histories is given, then that number of histories is
echoed rather than the number of histories set by the variable,
.B history.
.TP
.B ignore
Display or set a list of headers to be ignored when displaying messages.
When reading messages, all the message headers are displayed with the text
body of the message.  Since these message identifier fields are cumbersome
and uninteresting in many cases, you can filter out those headers by using the
.B ignore
command.
.sp
.ti +2
ignore Received Date Message-Id
.sp
The command,
.B unignore
is used to reverse the effects of
.B ignore.
These commands may be specified in the initializing files.
.TP
.B lpr [-Pname] [msg_list]
takes a message list and sends them, one by one, to the printer
each separated by page feeds.
A default printer name is supplied if one is not specified on the
command line (-Pprinter-name). If you have a variable
.B printer
set, that printer name will be used.
.sp
If the variable,
.B print_cmd
is set, the command described by that variable will be used instead
of the default system command.  In such cases, the -P option and the
.B printer
variable is ignored and the command is simply executed as is.  This is
useful for sending C source thruough pgrind or other formatting types of
commands.
.TP
.B ls
Just like the
.I UNIX
command
.I /bin/ls.
The variable,
.B lister
describes flags to be passed to ls automatically.  By default,
.I ls
always uses the -C flag (column output).
.TP
.B mail
(\fBm\fR) Send mail to a list of users. If no user list is specified on the
.I Mush
command line, then a "To: " prompt will request one.  A list of recipients
must be supplied.  This implementation of
.I Mush
supports mailing to files and programs as recipients. Filenames must
be full pathnames, thus, they must start with a '/' or there is no way to
know whether a recipient is a pathname or a real user.  The ~ is allowed
and is expanded to the user's home directory.  Mailing to programs is indicated
by the pipe `|' character preceding the program name.  Since the user's path
is searched, full pathnames are not required for programs.
.sp
Example:
.ti +2
mail username /path/to/filename "|program_name"
.sp
After, a
subject will be prompted for, but this heading is optional.
Optional flags are:
.nf
.in +2
.if t .ta 1.8i
-v	verbose (passed onto mail delivery program)
-e	immediately enter editor (autoedit)
-F	add random fortune to the end of message.
-i [msg_list]	include msg_list into letter.
-h [msg_list]	include msg_list with headers.
-f [msg_list]	forward msg_list (not indented).
.in -2
.fi
.TP
.B my_hdr/un_hdr
You can create personalized headers in your outgoing mail using this command.
.sp
.nf
Usages:
.in +2
.if t .ta 2.0i
my_hdr	prints all currently set headers
my_hdr header	value associated with header
my_hdr header: string	set header to string
un_hdr header:	unset header
.in -2
.sp
.fi
To set a header, the first argument must be a string
that contains no whitespace (spaces or tabs) and must end with
a colon ``:''. The rest of the command line is taken to be the
text associated with the mail header specified.
If any quotes are used in the header and the header itself is not set in
quotes, then quotes should be escaped (preceded) by a backslash. This holds
true for semicolons, pipe characters or any other metacharacter that
.I Mush
might interpret as a command line modifier.
.sp
If the variable,
.B no_hdrs
is set, then your headers will not be added to outgoing messages, but will
not unset any headers.
.B un_hdr
may take `*' as an argument to un_hdr everything set.
.TP
.B pick
allows the user to select particular messages from a folder.
With no arguments, pick will search each message for the previously
searched string (regular expression).  You can search for messages from a user,
for a particular subject line, between certain dates, and limit searches to
a range of messages.  You can also find all messages that do not
match the same arguments mentioned above.
.sp
.nf
Usage:
.ti +2
pick [-r \fImsg_list\fR] [-d [-][date]] [-s|-f|-t] [-x] [-i] [<pattern>]
.sp
.fi
Entire messages are scanned for a <pattern> unless -s, -f, or -t is specified.
Messages marked for deletion are also searched.
Only one of -s, -f, -t, and -d can be specified at once. No patterns can
be specified with the -d option.
.sp
.nf
Options:
.if t .ta 1.25i
.in +2
-r msg_list	restrict the range of messages search to "msg_list"
-s	search for pattern in the "subject" headers only.
-f	search for pattern in the "from" field (author) only.
-t	search for pattern in the "to" field only.
-i	ignore case of letters (upper and lower case are the same).
-d	print message headers on or after [`-' before] `date'.
-x	messages which do not contain the pattern. May not be used with -d.
.in -2
.fi
.sp
`date' is of the form: month/date/year. Omitted fields default to
today's values.
.sp
Examples on dates:
.nf
.in +2
.if t .ta 2.0i
.sp
pick -d 4/20	msgs on or after April 20, this year
pick -d -/2/85	on or before the 2nd, this month, 1985
pick -d /	today only.
.fi
.in -2
.sp
At least one `/' char must be used in date.
There is no strong date checking; 2/30 would be considered a valid date.
.sp
If no arguments are given, the previous expression searched for is used.
<pattern> is a "regular expression" described by `ed'.
.sp
Examples using
.B pick:
.sp
.ti +2
pick -d 2/5/86 | pick -d -2/5/87 | pick -s "mail stuff" | lpr
.sp
This will find all the messages between the dates February 5, 1986 and
February 5, 1987 that contain the subject "mail stuff" and print them.
.sp
.ti +2
pick -s Re: | delete
.sp
Deletes messages that have "Re:" in the subject
.sp
.ti +2
folder +project | pick -f frank
.sp
Finds all messages from frank in the folder described by +project.
.TP
.B preserve
(\fBpre\fR) Saves a message list in your spool directory rather than
your mailbox unless it has been explicitly deleted.  The variable
.B hold
causes all messages to be held in your spool directory automatically.
.TP
.B print
(\fBp, type, t\fR)
Takes a message list and types out each message on the user's terminal.
.TP
.B pwd
Prints the current working directory.
.TP
.B quit
(\fBq\fR)
Messages which have been read go to your
.I mbox
or the file described by the string variable
.B mbox.
If the variable "hold" then all messages not marked for deletion are
saved in the spool directory.
Messages marked for deletion are discarded.
Unread messages go back to the spool directory in all cases.
.TP
.B reply, replyall, respond
(\fBr, R\fR)
Messages are replied to by sending mail to the sender of each message
in the given message list.
.B replyall
responds to all the recipients as well as the
sender of the message.  You may pass
.B mail
flags as they are passed on to the
.B mail
command.
.sp
When contructing a return mail address to the author of a message,
.B replyall
searches for special mail headers in the author's message which
indicate the most efficient mail path for return mail.
.I Mush
will search for the following headers by default:
.B Reply-To:, Return-Path:, From:.
.sp
If none of these fields are found in the message, the first line of the
message is parsed; this "From " line is different from the "From: " line.
If the user wishes to change the order or the actual fields to search for
return paths, then the variable,
.B reply_to_hdr
is checked for a list of headers to be used (in the order specified).  If
.B reply_to_hdr
is set, but has no value, the first "From " line is used regardless of what
headers the author's message contains.  This is a special case setting for
the variable and the "From " line may not be specified explicitly or as an
item in the list of reply-to headers.
.sp
When replying to all recipients of the message using the
.B replyall (R)
command, only the original author's address can be obtained from
the message headers.  There is no way determine the best path to the
other recipients of the message from message headers aside from taking
their addresses directly from the To: and Cc: lines.
.sp
Normally, this isn't a problem with arpanet style addressing schemes.
The problems start with uucp because mail is not "one hop away."  That
is to say that mail must be routed through other computers, often many
of them, till the message finally gets to its desitination.  If the
original sender of the message was on a remote machine which your machine
may or may not exchange uucp mail with, then a uucp path will have to be
created to respond to the author.  However, if he mailed to other people
on machines which are also multi-hops away, the addresses he used for
those recipients may differ from what you should specify if you were to
try to reply to all everyone on the original message.
.sp
For example, if the original sender came from remote host,
.B pixar
and the list of recipients looked like,
.sp
.ti +2
To: r2d2!user1 r2d2!user2
.sp
you would not be able to respond to those users if your machine
did not connect with the host,
.B r2d2.
.sp
This problem will be attempted to be solved if the variable,
.B fixaddr
is set. If so, an attempt will be made to compensate by reconstructing
the addresses for user1 and user2 according to the address of the original
sender.  The new addresses for user1 and user2 should therefore become,
.sp
.ti +2
pixar!r2d2!user1, pixar!r2d2!user2.
.sp
There is an additional case where your machine calls
.B both
r2d2 and pixar. Then, it becomes unneccessary to route the mail through
pixar and then to r2d2 if you can deliver the mail directly yourself.
The variable,
.B known_hosts
may be set to a list of hosts which you know your machine to have
uucp mail connections with.  This list is checked when constructing
mail addresses and the shortest path is made by removing from the
uucp path those hosts which do not need to be called.  See the entry for
.B known_hosts
in the VARIABLES section.
.sp
If the variable,
.B auto_route
is set, all redundant hostnames from all uucp pathnames are removed
to avoid unnecessary uucp connections and improve speeding up mail delivery.
The reason for this stems from cases where a number of replies to the same
message go back and forth and the return address becomes long and contains
dedundancy.
.sp
.ti +2
pixar!island!sun!island!argv
.sp
Here, we have an example where mail was probably originally
sent to users at pixar and sun from somewhere undetermined now.  Since sun
and pixar do not talk to each other, the users on those machines may have
responded to mail creating the type of addresses stated above.
With auto_route set,
.I Mush
will modify this address to look like,
.sp
.ti +2
pixar!island!argv
.sp
This is not necessary for arpanet users since connections can almost always
be established without having to route through other arpanet hosts. If a
mixture of arpanet sites and uucp sites are mixed, then unknown results may
occur.
.TP
.B copy/save/write [!] [message list] [filename]
(\fBs\fR) With no arguments,
.B copy, save
and
.B write
will save the current message to the file,
.I mbox
in the user's home directory (or the file specified by the,
.B mbox
variable). If a message list is given, then the messages specified by
the list are saved.  If a filename is given, then that filename is used
instead of mbox.  If the file exists and is writable, the specified command
will append each message to the end of the file. If the `!' is given,
then the file is overwritten causing whatever contents it contains
to be lost. The
.B write
command differs from
.B save
and
.B copy
in that the message headers are
.I not
saved in the file along with the body of text.
.sp
If the current folder is the system mailbox, then saved messages are
marked for deletion when the user exits using the
.B quit
command. If the variable
.I keepsave
is set or the current folder is not the system mailbox, then messages are
not marked for deletion. The
.B copy
command is is like
.B save
except that messages are not marked for deletion regarless of whether
.B keepsave
is set or not.
.sp
Because message lists are used to determine the messages to be saved,
if the user wishes to save messages to a file that begins with a digit
or any other message list metacharacter, a back-slash should precede
the filename to escape the message list expansion routine.  The back-slash
will not be a part of the filename.
.TP
.B saveopts
The completement of
.B source, saveopts
will save all settable variables, aliases and cmd's in the initializing file.
(See the
.B source
command for more information on initializing files.)
If an argument is given, that file is used.  Beware that this will overwrite
files so any ``if'' expressions used will be lost. There is no prompting for
confirmation on overwrites, either.  Using saveopts is highly discouraged
and is intended for the naive user only.
.TP
.B set/unset
With no arguments, prints all variable values.  Otherwise, sets
option.  Arguments are of the form ``option=value'' (whitespace is allowed).
Boolean expressions need not have ``=value'' associated in the command.
The special command,
.I set ?all
will print all known variables utilized by the program and a brief description
of what they do. The user may set and manipulate his own set of variables, but
internal variables that are utilized by the program are the only ones displayed.
.sp
The command
.I set ?variable_name
will print the same information for one variable instead of all variables.
You may unset everything by issuing the command ``unset *''.  This is also
true for aliases, own_hdrs, ignored headers, cmds and function keys.
.TP
.B sh [command]
Invokes an interactive version of the shell. The shell spawned
is described by the variable,
.B shell.
If the optional argument,
.B command
is given, then that command is executed under the Bourne Shell.
If the special character `&' is at the end of any shell command,
then the command will be executed in background.
.TP
.B source
reads
.I Mush
commands from a file.  If no filename is specified, the files searched
for are .mushrc or .mailrc in the user's home directory.  If the environment
variable MAILRC is set, then that file is sourced.  If a filename is given
on the command line, that file is sourced. See the
.B INITIALIZATION
heading and the
.B home
variable descriptions for more information.
.TP
.B sort
will sort messages according to author, date, status or subject
(with or without considering the "Re: ", in replied messages). In
addition, the messages can be sorted in reverse order (same arguments).
.nf
sort [-] [d | a | s | S | R]
.in +2
-         reverse sort order.
d         sort according to date received.
a         author (alphabetical).
s         subject ignoring Re: as part of the subject.
R         subject (alphabetical).
S         by message status.
.in -2
.fi
By default (no arguments),
.B sort
sorts messages by status:
New, unread messages are first, followed by preserved messages
and finally the deleted messages are placed at the end of the list.
.sp
If the variable
.I sort
is set, messages are sorted each time the user's system mailbox is
read as the current folder.  The
.I sort
variable can be set to nothing or to legal "sort" arguments.
Note that only one argument (except for the `-'), may be used.
.sp
Subsorting can be acheived by using the piping mechanism intrinsic to
the line mode interface; no other interface allows subsorting "directly."
Each interface may allow subsorting if appropriate actions are taken discussed
later.
.sp
To subsort messages, the folder must be in a particular order to begin
with.  To sort mail by author and then by subject heading, you would
have to first sort by author:
.sp
.ti +2
sort a
.sp
Now that the messages are in order according to author, sorting a
sublist of messages is done using pipes:
.sp
.ti +2
pick -f island!argv@sun.com | sort s
.sp
This finds all messages from the user, "island!argv@sun.com" and sorts them 
by subject.  Since these messages are already grouped together via the
previous sort command, the sorting by subject (s) will restrict itself
to such messages.  You may specify the exact message list by specifying
that message list on the command line and using a pipe:
.sp
.ti +2
10-. | sort d
.sp
This command means to sort the messages from 10 to the current message
according to the date.
.sp
To specify subsorting from with the curses interface, the temporary
curses escape key must be used (the colon ':') and the command issued
at the command line given (as if giving an ``ex'' command to ``vi'').
When the command is finished, the "...continue..." prompt is given and
the user may continue or return to the top level of the curses mode.
.sp
In the tool interface, the user must map a function key to the desired
command.  Select the "Opts" icon with the right mouse button, choose
the menu item labeled, "function keys" and user the interface provided
to set a function key to the desired piped mechanism.
.TP
.B stop
For systems with job control, stop will cause
.I Mush
to send a SIGTSTP to itself. The command was introduced to facilitate
the stop-job action from a complex command line alias rather than the user
having to type his stop character explicitly.
.TP
.B top
Takes a message list and prints the top few lines of each.
The number of lines printed is controlled by the variable
.B toplines
and defaults to the size of the value of the variable
.B crt.
This command is ignored in the tool mode.
.SH VARIABLES
.PP
Shell variables are controlled via the
.B set
and
.B unset
commands.  Options may be either boolean, in which case it is only
significant to see whether they are set or not, string, in which
case the actual value is of interest, or numerical, in which the
numerical value is important.  Some variables may have attributes
of boolean and string at the same time.
.sp
If you or the program references a variable which is not explicitly set,
then the environment variables are checked and a pointer to that data
is returned.
.TP
.B alwaysignore (boolean)
If set, the mail headers set by the
.B ignore
command are always ignored.
Normally, ignore will only ignore headers when reading, saving(writing)
to files, or interpolating messages into letters with the ~f escape. See the
.B ignore
command for more information.
.TP
.B askcc (boolean)
If set, you will be prompted for a Cc list (carbon copy) when you are finished
editing a letter to be sent.  In the tool mode, this is ignored; the Cc list
is always prompted for after the Subject is prompted.
.TP
.B autodelete (boolean)
When exiting mail, all messages which have been read
.I regardless of whether they have been marked for deletion
are removed. Only messages that haven't been read or marked as
.B preserved,
are not removed.
.TP
.B autoedit (boolean)
If set, you are automatically put into your editor whenever you
send or reply to mail.
.TP
.B autoinclude (boolean)
When replying to any mail, a copy of the message being replied to
is automatically inserted into your message body indented by
the string described by the variable
.B indent_str.
.TP
.B autoprint (boolean)
After you delete a message, the next message is printed automatically.
.TP
.B auto_route
Automatic trancation of uucp address to a more brief and efficient path
is attempted resulting in faster mail delivery.  Redundant hostnames are
removed from the uucp path if they occur and heuristics are used to
determine the shortest path to the desination based on return addresses.
Also see the variables,
.B known_hosts, fixaddr,
and the command,
.B replyall.
.TP
.B autosign (boolean/string)
If the variable is set,
but not to a string (e.g. boolean-true), then the file ~/.signature is used.
.sp
Otherwise, the variable is interpreted as a pathname opened relative to
the current directory.  For this reason, it is adviseable to use full
pathnames here.  As usual, the ~ and + are expanded as described earlier.
If the file is found, it is opened and its contents are read into the
message buffer.
.sp
If the variable is set to a string that begins with `$', then the string
is interpreted as a user definable variable and it is expanded and appended
to the letter.
.sp
Finally, if the variable is set to a string that begins with a backslash (\\),
then the string itself (minus the \\ character) is used and no expansion
is done and no files are read.
.sp
In the latter two cases, it is advisable to set the variable using single
quotes to avoid expanding the variable beforehand or from eliminating the
backslash.  For example,
.br
.nf
set autosign = '$foo'
set autosign = '\\this is an exmple string.'
.fi
.TP
.B crt (numeric)
Set to a value which describes the number of lines a message
must have before invoking the
.B pager
to view a message.
.TP
.B cwd (string)
The
.B current working directory
string is automatically set upon startup of
.I Mush
and each time the command,
.B cd,
is called. It is referenced each time
.B pwd
is called and may be used as any other shell variable.
.TP
.B dead (string)
File to use instead of "dead.letter" when dead mail is saved.
.TP
.B dot (boolean)
Accepts a "." on a line by itself instead of ^D to terminate letter.
.TP
.B editor (string)
Editor to use when ~e is specified. Default is the value of the variable,
.B visual.
.TP
.B escape (character)
When typing in a letter (not in an editor), when the
.B escape
character is the first character on the line, the following character
is examined and a corresponding function associated with that
.B escape command
is executed.  See
.B tilde escapes
for more information.
.TP
.B fixaddr (boolean)
Causes replyall to modify the return addresses of all recipients to
route through the original sender's host.  Mostly used for uucp mail.
See the
.B replyall
command for more detailed information.
.TP
.B folder (string)
The folder variable is set to a path where folders are kept. ~/Mail
is the default value.
.TP
.B fortune (boolean/string)
If fortune is set, a random fortune is appended to the end of
all outgoing mail using the
.I UNIX
command,
.B /usr/games/fortune
(may vary from system to system).
If fortune is set to something that starts with
a '-', then it is interpreted as a flag to fortune (e.g. "-o"). If
.B fortune
starts with a '/', then the program described by
the string is executed (thus not doing fortune at all, if you want).
By default, fortune -s (short fortunes) is used.
.TP
.B fortunates (string)
This is a variable set to a list of people who, if any are
on the To: line, or the Cc: line, a fortune is added.
If those lists do not contain names which are on the fortunates
list, then no fortune is added.
.I "NOTE: fortune must be set in order for fortunates to work."
.TP
.B hdr_format (string)
See the description of hdr_format above.
.TP
.B hold (boolean)
Normally, on termination of mail, read messages are saved in
mbox (except those marked as preserved).  Hold, prevents this
from happening and messages remain in /usr/spool/mail/user.
This does not apply to folders, obviously.
.TP
.B home (string)
This variable describes the user's home directory. The variable
is initialized to the value of the environment variable, HOME,
but can be modified at any time during the
.I Mush
session.  The home directory is the same directory where temporary
files are kept for editing and so forth. If the home directory cannot
be found or read/write access is denied, an alternate directory, typically
/tmp, is used.
.TP
.B ignore_bang (boolean)
Ignore the `!' character as a history reference.
.TP
.B ignoreeof (boolean/string)
If set, ^D will not exit mail.  If set to a "string", that string is
executed as a command.
.TP
.B indent_str (string)
When including messages into the text of a letter you are editing,
the messages are preceded by whatever is described by indent_str.
The default string used is "> ".
.TP
.B keepsave (boolean)
If set, the commands,
.I save
and
.I write
will
.B not
mark messages for deletion.
.TP
.B known_hosts (string)
Used in conjunction with the variable,
.B auto_route,
this variable is set to a list of hosts, separated by spaces, tabs,
and/or commas, and describes
the hosts with whom you know your machine shares uucp connections.
When replying to mail, many times you will see the return path constructed
will have hostnames which your site could call, but instead the mail would
be routed throughout a number of different machines first.
.sp
For example, if you respond to mail which would mail to the path,
.sp
.ti +2
unicom!pixar!root
.sp
but your know your machine already calls pixar, then sending the mail
to unicom first would be unneccessary.  If you have your known_hosts
string include pixar in its list, the resulting address would look like,
.sp
.ti +2
pixar!root
.sp
Also see the command,
.B replyall
for more information on constructing more correct return addresses.
.TP
.B lister (string)
Default arguments to the "ls" command for printing the
contents of a directory.
.TP
.B mbox (string)
Set to the pathname of a file you'd like mush to use as the default
holder for read mail.  The default is ~/mbox.
.TP
.B metoo (boolean)
When replying to mail, you are normally deleted from the list of
recipients. If metoo is set, you remain on the list. See alternates
for information on determining whether or not you're even on the list.
.TP
.B newline (boolean/string)
If set, Carriage Returns are ignored, if set to a "string", that string is
executed as a command.  Otherwise CR's read the next undeleted message.
.TP
.B no_hdr (boolean)
Don't include your personalized mail headers in messages. This does
not unset your headers, it just disables them from being specified.
.TP
.B no_reverse
In curses mode and in the tool mode, reverse video is not used to indicate the 
.I current message.
In the tool mode, if reverse video is not in use, text is displayed in "bold".
.TP
.B nosave (boolean)
If set, terminated mail is not saved in dead.letter
.TP
.B pager (string)
If a message is longer than what the variable
.B crt
is set to, then this program is executed to view a message. The
default value for pager is /usr/ucb/more.
.TP
.B printer (string)
Used to set the default printer for the lpr command.
.TP
.B prompt (string)
You can set your prompt to tell you many different pieces of information.
By default, the prompt is set to the string,
.ti +2
"Msg %m of %t: "
.br
If you have 10 messages and your current message is 5, then your prompt
would look like:
.ti +2
Msg 5 of 10:
.br
The string variable
.B prompt
can be set to display other information.
The string value that prompt is set to will be printed as your
prompt.  If the string contains a ``%'', then that character is
ignored and the next character is evaluated and an appropriate
value is printed in its place:
.nf
.in +2
%m  expands to the "current message" number.
%t  total number of messages.
%u  number of unread messages.
%d  number of deleted messages.
%n  number of "new" messages.
%f  expands to the filename of the current folder.
%T  the current time (hours and seconds).
%D  today's day (sun, mon, tues...).
%N  today's date (Number of the day in the month).
%Y  this year.
\\n  \ \ will have a RETURN in the prompt.
\\t  \ \ a tab.
.fi
.in -2
.TP
.B quiet (boolean)
If set, the currently running version of
.I Mush
is not printed on startup.
.TP
.B record (string)
Set to the name of a file to record all outgoing mail. This should be a
full pathname or the current directory is searched.  The pathname may begin
with ``+'' (indicating the user's ~/Mail directory or described by $folder)
or with a ``~'' indicating the user's home directory (or ~user).
.TP
.B reply_to_hdr (string)
When replying to mail,
.I Mush
searches for return paths from the message by searching for
the message headings, "reply-to", "return-path", and "from:"
respectively.  If none are found, then the first line of the
message created by the delivery system is parsed and the address
given there is used.  If the variable,
.B reply_to_hdr
is set, then the list of headers (delimited by spaces or commas)
is searched.  If none of the headers listed in the variable exist
in the message, then a warning message is printed and the default
headers are used.
.TP
.B screen (numerical value)
Number of message headers to display at a time.
.TP
.B screen_win (numerical value)
Number of message headers to display in the tool mode.  There
is a subwindow for message headers and its size is large enough
to hold `screen_win' number of headers.
.TP
.B show_deleted (boolean)
If true, deleted message headers are displayed along with
other messages ('*' indicates a deleted message).  In curses mode,
this variable is ignored and deleted messages are always displayed
with other messages to facilitate undeleting messages.
.TP
.B squeeze
Whenever messages are read, piped, or saved, if this variable is set,
all consecutive blank lines are squeezed into one blank line.
.TP
.B toplines (numerical value)
The number of lines of a message to print when the "top" command
is issued.  If unset, `crt' lines are printed.
.TP
.B unix (boolean)
If set, commands which are not
.I Mush
commands are considered to be
.I UNIX
commands.  This removes the inconvenience of requiring the user to do
shell escapes to do quick UNIX commands.  For systems that support job
control, SIGTSTP will stop the entire shell as well as the process
being executed.  When SIGCONT is delivered, both will receive the
signal and the shell will continue to wait for the job to finish.
.sp
The lack of real job control, input/output redirection and UNIX command piping,
this mode of the shell is not intended to be used as a login shell.
.sp
If a
.I Mush
command conflicts with a UNIX command, use 'sh' to override the shell command.
.sp
.I "WARNING: Be aware that Mush commands return message lists, NOT TEXT.\ "
You cannot pipe UNIX or shell commands to or from UNIX commands.
UNIX commands should be simple commands without pipes or metacharacters.
.sp
This feature is not available for the graphics (tool-based) mode.
.TP
.B verbose (boolean)
Passes verbose flag to mail delivery systems when sending mail.
.TP
.B verify (boolean)
When through editing messages, just before sending,
.B verify
will ask you if you want to send, continue editing, or abort the
whole message all together.
.TP
.B visual (string)
Visual editor to use when ~v is specified. Default is vi. The visual
editor is invoked with -e arguments to the commands, "respond" and "mail."
.TP
.B warning (boolean)
If set, warning messages are printed when:
.in +4
.ti -2
\(bu a command line alias (`cmd') looks like a command.  For example,
.br
cmd mail 'set fortune; \\mail'
.br
cmd respond 'unset fortune; \\respond;'
.br
.ti -2
\(bu a variable is set differently from its default value.
For example, if the escape character is set to something other
that the tilde ( ~ ), then a warning message will be printed.
.in -4
.sp
The intent is so that users who are used to their own environments
will be aware of changes in other environments should they be forced
to use them.
.SH FILES
.if n .ta 2.5i
.if t .ta 1.8i
/usr/spool/mail/*	The directory for incoming mail.
.br
~/Mail	Default \fBfolder\fR directory.
.br
~/mbox	Old Mail.
.br
~/.mushrc	File giving initial \fIMush\fR commands.
.br
~/.mailrc	Alternate initialization file.
.br
~/.edXXXXXXX	Temporary for file for outgoing messages.
.br
~/.mushXXXXXX	Temporary mail file (copy of current folder).
.PP
Temporary files which are created by the program are always
created with read/write access to the owner only; group and other
permissions are never set.  This is also true for the /usr/spool/mail/*
files.  All other files created by the user via commands internal or
external to the program have permissions set by the user's default
umask.  If the umask is reset within the program, the mask remains
in tact even after exiting.  Remember to set the variable,
.B unix
before attempting to set the umask value.
.PP
If your system is using Sun Microsystem's NFS, take special note to
read the manual page for mount(1). Filesystems mounted for read/write
access should be mounted as "hard" NFS mounts or you may lose mailboxes
during a timeout during a write or update.
.PP
Filesystems that use RFS still have bugs to be ironed out in the way
of owners and permissions concerning utime(2).
.sp
.SH "SEE ALSO"
Mail(1), binmail(1), csh(1), aliases(5), mount(1),
mailaddr(7), sendmail(8), printf(3), execl(3), umask(1), utime(2).
.sp
.SH AUTHOR
This code was written entirely by Dan Heller and contains no UNIX sources
or is a modified version of any other mailer.  Similarities with any other
mailer previous to
.I Mush
may have been designed for compatibility reasons with such mailers, but
no source code was barrowed, or even referenced to develop
.I Mush.
.PP
argv@spam.istc.sri.com	island!argv@sun.com
.sp
.SH BUGS
The curses interface uses the curses library.  The routines from the
library that are used are the most basic and simple to avoid possible
bugginess that different versions of UNIX might have.  However, one
unavoidable problem is the reverse video mode.  Depending on your terminal,
the termcap entry for it, and the version of curses you are running,
the reverse video may makes things worse than desired.  In such situations,
the user should set the variable,
.B no_reverse
to not get reverse video.  ^R may still be entered at runtime in the curses
interface to toggle reverse video.
.sp
If the program is already running and the system [later] has to swap
and there is no swap space left, there may be problems. One such
problem is sending mail.  If this happens, then sending mail
will fail and a segmentation fault from the spawned forked child will occur
unless the -v flag was given to mail.  The unsent letter will
not be removed from the editing file ($home/.edXXXXXX) and may be recovered.
.sp
Many functions available to the line oriented mode (shell mode)
are not available to the tool mode. For example,
.B pick
may not be directly accessed although experienced users may find that
typing pick commands within single backquotes in the "range" panel item
in the header window will indeed pick messages.  This is mostly for selecting
the "delete range" item or the middle mouse button icon in the header panel.
.sp
Shell escapes (of any kind) may not be called from
the tool/graphics mode. The reason for this is that there is no tty
.I window
to run commands from.  It is impossible to determine whether or
not the user wants to run an interactive program or not so it is
best to disallow its usage all together. The experienced window user
can figure out how to really do shell layers from within the tool mode.
.sp
Toggling from the curses mode to the line mode to get the full
functionality of the shell/line mode is unfortunately necessary
in the name of "user friendliness."  Mostly, this is only necessary
for piping of commands and using the pick command.
.sp
The function keys and their ability to
.I work
has been variable depending on the version of SunWindows/SunView
your Sun Workstation has.  From time to time, it works, but when it
doesn't, it seems to be related to other user or system definable
dot-files or whatever. I hardly use them, so I haven't had a chance
to really debug that part much.  My experiences have shown them to
work in Sun versions 2.0, 2.2, and 3.3, but not 2.2, 2.3, 3.0 or 3.2.
.sp
When using
.B vi
in the tool/graphics mode, periodically the window will be one line
"short."  That is, scrolling will be off by one and line and you may
have to redraw the window (using `z.' in vi) to get it in sync again.
This is a known problem with SunWindows, but Sun refuses to fix it
as SunWindows are "obsolete."
.sp
When running on full filesystems,
.I Mush
may complain or not even run since it needs temporary space with which
to work.  Instead of finding new filesystems on it's own,
.I Mush
leaves this task up to the user. The workaround is to set the variable
.B home
in the initialization file to be a writable place in a filesystem which
has enough disk space.  This will set the user's home directory to be
set incorrectly, but resetting the home manually once in the shell
will correct the problem.
.sp
Most of the other known and documented bugs
are in the supplied README file accompanying the source.  Of course,
the source is an excellent place to look as most known bugs are documented
right in the source code.  A good way to track suspicious bugs is to use the
.B debug
command. This command is very difficult to use in curses mode.
