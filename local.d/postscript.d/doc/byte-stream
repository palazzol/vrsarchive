A byte Stream Protocol for low-level graphics operations in PostScript.

The PostScript interpreter does a great deal of work, so the actual
graphics primitives are not usually a bottle-neck. It thus makes sense
to run the interpreter on a number-cruncher and watch the graphics on a
bitmapped display.

This file describes a byte-stream protocol which has been used to
implement this.  It is clear that Remote Procedure Call is the correct
way to solve this problem - this interface is described because it is
portable and expedient. Most RPC mechanisms are intimately tied to a
network protocol of some description. This implementation works through
pipes and can be sent accross a network with rsh(1) on 4.2BSD.

A version may appear which uses only a simple command language with no
enquiry. This unfortunately cannot provide the full functionality
required. It would not be possible to read back cached fonts from the
viewer for example, as they are held at that end.

The byte-stream is composed of requests of variable length. The first
byte in each request is a type byte and the format of the remaining
bytes is determined by this.

The current formats are as follows. An indented following line
indicates the expected reply (if any).

NEW_WINDOW	hard channel; short width, height;
		/* create a displayed bitmap of the required size. The
		initial content is unimportant, as it will be cleared
		to user-white later */
NEW_BITMAP	hard channel; short width, height;
		/* create a non-displayed bitmap. These may vary from
		full-screen size down to character sizes and are used
		for caching fonts (among other things */
BITBLT		hard fromchan, tochan; point fromOrigin, toOrigin, extent;
		rop rasterOp;
		/* general purpose rasterop */
SEND_BITMAP	hard channel; short width, height; string data;
		/* create a bitmap of the given size and put the
		following bits in it. */
GET_BITMAP	hard channel;
		string data;
		/* return an encoded bitmap describing the given
		bitmap. The ability to dump from a window is not yet
		used, but may be in the future. */
DESTROY_HARDWARE	hard channel;
		/* release the bitmap or window associated with a channel */
LINE		hard channel; point from, to; rop rasterOp;
		/* draw a line as required */
GET_MATRIX	short width, height;
		float A, B, C, D, tx, ty;
GET_TRANSFERSIZE
		short size;
SET_TRANSFER	small tran[size];
PAINT		hard fromchan, tochan; point fromOrigin, toOrigin, extent;
		/* fromchan will be a bitmap, tochan will be a window.
		This is the only combination currently required */
PAINT_LINE	hard channel; point from, to; small hue, sat, bright;
		/* paint a line as required */

HARD_FLUSH	/* flush hardware output buffer before user gets prompted
		(if necessary) */

SCREEN_SIZE	float frequency, rotation;
		short size;

BUILD_SCREEN	float frequency, rotation;
		short size; small *x, *y;
		/* returns XY pairs x[0], y[0], x[1], y[1], ... for
		spot function */

SET_SCREEN	float frequency, rotation; small *thresh;
		/* send vector of thresholds from spot-function */
		

hard	= short
short 	= low byte followed by high byte
small	= short from float scaled by 16384 - the float is expected to be in
		the range -1 to +1
float	= free format printable representation terminated by newline as
		generated by printf("%g\n", arg);
point	= short x, y;	origin is expected to be top-left and units are
		device pixels.
string 	= an encoding of a bitmap. msb is leftmost, rows are padded to
		byte-boundaries. Length is computed from the size of the
		relevant bitmap.
rop	= byte	- the meanings are as follows:

#define ROP_FALSE	0	/* F		*/
#define ROP_AND		1	/* S & D	*/
#define ROP_ANDNOT	2	/* S & ~D	*/
#define ROP_SOURCE	3	/* S		*/
#define ROP_NOTAND	4	/* ~S & D	*/
#define ROP_DEST	5	/* D		*/
#define ROP_XOR		6	/* S ^ D	*/
#define ROP_OR		7	/* S | D	*/
#define ROP_NOR		8	/* ~(S | D)	*/
#define ROP_NXOR	9	/* ~(S ^ D)	*/
#define ROP_NOTDEST	10	/* ~D		*/
#define ROP_ORNOT	11	/* S | ~D	*/
#define ROP_NOTSOURCE	12	/* ~S		*/
#define ROP_NOTOR	13	/* ~S | D	*/
#define ROP_NAND	14	/* ~(S & D)	*/
#define ROP_TRUE	15	/* T		*/
