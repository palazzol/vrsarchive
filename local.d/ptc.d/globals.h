/***************************************************************************/
/***************************************************************************/
/**									  **/
/**	Copyright (C) 1987 by Per Bergsten, Gothenburg, Sweden		  **/
/**									  **/
/**	No part of this program, or parts derived from this program,	  **/
/**	may be sold, hired or otherwise exploited without the author's	  **/
/**	written consent.						  **/
/**									  **/
/**	The program may be freely redistributed provided that:		  **/
/**									  **/
/**		1) the original program text, including this notice,	  **/
/**		   is reproduced unaltered,				  **/
/**		2) no charge (other than a nominal media cost) is	  **/
/**		   demanded for the copy.				  **/
/**									  **/
/**	The program may be included in a package only on the condition	  **/
/**	that the package as a whole is distributed at media cost.	  **/
/**									  **/
/***************************************************************************/
/***************************************************************************/
/**									  **/
/**	The program is a Pascal-to-C translator.			  **/
/**	It accepts a correct Pascal program and creates a C program	  **/
/**	with the same behaviour. It is not a complete compiler in the	  **/
/**	sense that it does NOT do complete typechecking or error-	  **/
/**	reporting. Only a minimal typecheck is done so that the meaning	  **/
/**	of each construct can be determined. Therefore, an incorrect	  **/
/**	Pascal program can easily cause the translator to malfunction.	  **/
/**									  **/
/***************************************************************************/
/***************************************************************************/
/**									  **/
/**	Things which are known to be dependent on the underlying cha-	  **/
/**	racterset are marked with a comment containing the word	CHAR.	  **/
/**	Things that are known to be dependent on the host operating	  **/
/**	system are marked with a comment containing the word OS.	  **/
/**	Things known to be dependent on the cpu and/or the target C-	  **/
/**	implementation are marked with the word CPU.			  **/
/**	Things dependent on the target C-library are marked with LIB.	  **/
/**									  **/
/**	The code generated by the translator assumes that there	is a	  **/
/**	C-implementation with at least a reasonable <stdio> library	  **/
/**	since all input/output is implemented in terms of C functions	  **/
/**	like fprintf(), getc(), fopen(), rewind() etc.			  **/
/**	If the source-program uses Pascal functions like sin(), sqrt()	  **/
/**	etc, there must also exist such functions in the C-library.	  **/
/**									  **/
/***************************************************************************/
/***************************************************************************/
/*
**	Code derived from program ptc
*/
extern void	exit();
/*
**	Definitions for i/o
*/
# include <stdio.h>
typedef struct {
	FILE	*fp;
	unsigned short	eoln:1,
			eof:1,
			out:1,
			init:1,
			:12;
	char	buf;
} 	text;
#ifndef EQUALS
# define EQUALS(c)
text	input;
text	output;
#else
text	input = { stdin, 0, 0 };
text	output = { stdout, 0, 0 };
#endif
# define Fread(x, f) fread((char *)&x, sizeof(x), 1, f)
# define Get(f) Fread((f).buf, (f).fp)
# define Getx(f) (f).init = 1, (f).eoln = (((f).buf = fgetc((f).fp)) == '\n') ? (((f).buf = ' '), 1) : 0
# define Getchr(f) (f).buf, Getx(f)
FILE	*Tmpfil;
long	Tmplng;
double	Tmpdbl;
# define Fscan(f) (f).init ? ungetc((f).buf, (f).fp) : 0, Tmpfil = (f).fp
# define Scan(p, a) Scanck(fscanf(Tmpfil, p, a))
void	Scanck();
# define Eoln(f) ((f).eoln ? true : false)
# define Eof(f) ((((f).init == 0) ? (Get(f)) : 0, ((f).eof ? 1 : feof((f).fp))) ? true : false)
# define Fwrite(x, f) fwrite((char *)&x, sizeof(x), 1, f)
# define Put(f) Fwrite((f).buf, (f).fp)
# define Putx(f) (f).eoln = ((f).buf == '\n'), (void)fputc((f).buf, (f).fp)
# define Putchr(c, f) (f).buf = (c), Putx(f)
# define Putl(f, v) (f).eoln = v
/*
**	Definitions for case-statements
**	and for non-local gotos
*/
# define Line __LINE__
void	Caseerror();
# include <setjmp.h>
struct Jb { jmp_buf	jb; } J[1];
/*
**	Definitions for standard types
*/
extern int strncmp();
# define Cmpstr(x, y) strncmp((x), (y), sizeof(x))
typedef char	boolean;
# define false (boolean)0
# define true (boolean)1
extern char	*Bools[];
typedef long	integer;
# define maxint	2147483647
extern void abort();
/*
**	Definitions for pointers
*/
# ifndef Unionoffs
# define Unionoffs(p, m) (((long)(&(p)->m))-((long)(p)))
# endif
# define NIL 0
extern char *malloc();
/*
**	Definitions for set-operations
*/
# define Claimset() (void)Currset(0, (setptr)0)
# define Newset() Currset(1, (setptr)0)
# define Saveset(s) Currset(2, s)
# define setbits 15
typedef unsigned short	setword;
typedef setword *	setptr;
boolean	Member(), Le(), Ge(), Eq(), Ne();
setptr	Union(), Diff();
setptr	Insmem(), Mksubr();
setptr	Currset(), Inter();
setptr	Tmpset;
extern setptr	Conset[];
void	Setncpy();
extern char *strncpy();
/*
**	Start of program definitions
*/
char	version[]	EQUALS("From: @(#)ptc.p	1.5  Date 87/05/01");
char	sccsid[]	EQUALS("@(#)ptc.c	1.2 Date 87/05/09");
# define keytablen 38
# define keywordlen 10
char	othersym[]	EQUALS("otherwise ");
char	externsym[]	EQUALS("external  ");
char	dummysym[]	EQUALS("          ");
char	wordtype[]	EQUALS("unsigned short");
# define C37_setbits 15
char	filebits[]	EQUALS("unsigned short");
# define filefill 12
# define maxsetrange 15
# define scalbase 0
# define maxprio 7
# define maxmachdefs 8
# define machdeflen 16
# define maxstrblk 1023
# define maxblkcnt 63
# define maxstrstor 65535
# define maxtoknlen 127
# define hashmax 64
# define null 0
# define minchar null
# define maxchar 127
char	tmpfilename[]	EQUALS("\"/tmp/ptc%d%c\", getpid(), ");
# define space ' '
# define tab1 '	'
char	tab2[]	EQUALS("		");
char	tab3[]	EQUALS("			");
char	tab4[]	EQUALS("				");
# define bslash '\\'
char	nlchr[]	EQUALS("'\\n'");
char	ffchr[]	EQUALS("'\\f'");
char	nulchr[]	EQUALS("'\\0'");
char	spchr[]	EQUALS("' '");
# define quote '\''
# define cite '"'
# define xpnent 'e'
# define percent '%'
# define uscore '_'
# define badchr '?'
# define okchr quote
# define tabwidth 8
# define echo true
# define diffcomm false
# define lazyfor false
# define unionnew true
char	inttyp[]	EQUALS("int");
char	chartyp[]	EQUALS("char");
char	setwtyp[]	EQUALS("setword");
char	setptyp[]	EQUALS("setptr");
char	floattyp[]	EQUALS("float");
char	doubletyp[]	EQUALS("double");
char	dblcast[]	EQUALS("(double)");
# define realtyp doubletyp
char	voidtyp[]	EQUALS("void");
char	voidcast[]	EQUALS("(void)");
# define intlen 10
# define fixlen 20
char	C24_include[]	EQUALS("# include ");
char	C4_define[]	EQUALS("# define ");
char	ifdef[]	EQUALS("# ifdef ");
char	ifndef[]	EQUALS("# ifndef ");
char	elsif[]	EQUALS("# else");
char	endif[]	EQUALS("# endif");
char	C50_static[]	EQUALS("static ");
char	xtern[]	EQUALS("extern ");
char	typdef[]	EQUALS("typedef ");
char	registr[]	EQUALS("register ");
# define indstep 8
typedef unsigned char	hashtyp;
typedef unsigned short	strindx;
typedef unsigned short	strbidx;
typedef struct { char	A[maxstrblk + 1]; }	strblk;
typedef strblk *	strptr;
typedef unsigned char	strbcnt;
typedef struct S59 *	idptr;
typedef struct S59 {
	idptr	inext;
	unsigned char	inref;
	hashtyp	ihash;
	strindx	istr;
}	idnode;
typedef unsigned char	toknidx;
typedef struct { char	A[maxtoknlen - 1 + 1]; }	toknbuf;
typedef struct { char	A[keywordlen - 1 + 1]; }	keyword;
typedef enum { dabs, darctan, dargc, dargv,
	dboolean, dchar, dchr, dclose,
	dcos, ddispose, deof, deoln,
	dexit, dexp, dfalse, dflush,
	dget, dhalt, dinput, dinteger,
	dln, dmaxint, dmessage, dnew,
	dodd, dord, doutput, dpage,
	dpack, dpred, dput, dread,
	dreadln, dreal, dreset, drewrite,
	dround, dsin, dsqr, dsqrt,
	dsucc, dtext, dtrue, dtrunc,
	dtan, dwrite, dwriteln, dunpack,
	dzinit, dztring } 	predefs;
typedef enum { sand, sarray, sbegin, scase,
	sconst, sdiv, sdo, sdownto,
	selse, send, sextern, sfile,
	sfor, sforward, sfunc, sgoto,
	sif, sinn, slabel, smod,
	snil, snot, sof, sor,
	sother, spacked, sproc, spgm,
	srecord, srepeat, sset, sthen,
	sto, stype, suntil, svar,
	swhile, swith, seof, sinteger,
	sreal, sstring, schar, sid,
	splus, sminus, smul, squot,
	sarrow, slpar, srpar, slbrack,
	srbrack, seq, sne, slt,
	sle, sgt, sge, scomma,
	scolon, ssemic, sassign, sdotdot,
	sdot } 	symtyp;
typedef struct { setword	S[6]; }	symset;
typedef struct S180 {
	symtyp	st;
	union {
		struct  {
			idptr	vid;
		} V1;
		struct  {
			char	vchr;
		} V2;
		struct  {
			integer	vint;
		} V3;
		struct  {
			strindx	vflt;
		} V4;
		struct  {
			strindx	vstr;
		} V5;
	} U;
}	lexsym;
typedef enum { lpredef, lidentifier, lfield, lforward,
	lpointer, lstring, llabel, lforwlab,
	linteger, lreal, lcharacter } 	ltypes;
typedef struct S60 *	declptr;
typedef struct S61 *	treeptr;
typedef struct S62 *	symptr;
typedef struct S62 {
	treeptr	lsymdecl;
	symptr	lnext;
	declptr	ldecl;
	ltypes	lt;
	union {
		struct  {
			idptr	lid;
			boolean	lused;
		} V6;
		struct  {
			strindx	lstr;
		} V7;
		struct  {
			strindx	lfloat;
		} V8;
		struct  {
			integer	lno;
			boolean	lgo;
		} V9;
		struct  {
			integer	linum;
		} V10;
		struct  {
			char	lchar;
		} V11;
	} U;
}	symnode;
typedef struct S60 {
	declptr	dprev;
	struct { symptr	A[hashmax + 1]; }	ddecl;
}	declnode;
typedef enum { npredef, npgm, nfunc, nproc,
	nlabel, nconst, ntype, nvar,
	nvalpar, nvarpar, nparproc, nparfunc,
	nsubrange, nvariant, nfield, nrecord,
	narray, nconfarr, nfileof, nsetof,
	nbegin, nptr, nscalar, nif,
	nwhile, nrepeat, nfor, ncase,
	nchoise, ngoto, nwith, nwithvar,
	nempty, nlabstmt, nassign, nformat,
	nin, neq, nne, nlt,
	nle, ngt, nge, nor,
	nplus, nminus, nand, nmul,
	ndiv, nmod, nquot, nnot,
	numinus, nuplus, nset, nrange,
	nindex, nselect, nderef, ncall,
	nid, nchar, ninteger, nreal,
	nstring, nnil, npush, npop,
	nbreak } 	treetyp;
typedef enum { tnone, tboolean, tchar, tinteger,
	treal, tstring, tnil, tset,
	ttext, tpoly, terror } 	pretyps;
typedef enum { anone, aregister, aextern, areference } 	attributes;
typedef struct S61 {
	treeptr	tnext, ttype, tup;
	treetyp	tt;
	union {
		struct  {
			predefs	tdef;
			pretyps	tobtyp;
		} V12;
		struct  {
			treeptr	tsubid, tsubpar, tfuntyp, tsublab,
				tsubconst, tsubtype, tsubvar, tsubsub,
				tsubstmt;
			integer	tstat;
			declptr	tscope;
		} V13;
		struct  {
			treeptr	tidl, tbind;
			attributes	tattr;
		} V14;
		struct  {
			treeptr	tparid, tparparm, tpartyp;
		} V15;
		struct  {
			treeptr	tptrid;
			boolean	tptrflag;
		} V16;
		struct  {
			treeptr	tscalid;
		} V17;
		struct  {
			treeptr	tof;
		} V18;
		struct  {
			treeptr	tlo, thi;
		} V19;
		struct  {
			treeptr	tselct, tvrnt;
		} V20;
		struct  {
			treeptr	tflist, tvlist;
			idptr	tuid;
			declptr	trscope;
		} V21;
		struct  {
			treeptr	tcindx, tindtyp, tcelem;
			idptr	tcuid;
		} V22;
		struct  {
			treeptr	taindx, taelem;
		} V23;
		struct  {
			treeptr	tbegin;
		} V24;
		struct  {
			treeptr	tlabno, tstmt;
		} V25;
		struct  {
			treeptr	tlabel;
		} V26;
		struct  {
			treeptr	tlhs, trhs;
		} V27;
		struct  {
			treeptr	tglob, tloc, ttmp;
		} V28;
		struct  {
			treeptr	tbrkid, tbrkxp;
		} V29;
		struct  {
			treeptr	tcall, taparm;
		} V30;
		struct  {
			treeptr	tifxp, tthen, telse;
		} V31;
		struct  {
			treeptr	twhixp, twhistmt;
		} V32;
		struct  {
			treeptr	treptstmt, treptxp;
		} V33;
		struct  {
			treeptr	tforid, tfrom, tto, tforstmt;
			boolean	tincr;
		} V34;
		struct  {
			treeptr	tcasxp, tcaslst, tcasother;
		} V35;
		struct  {
			treeptr	tchocon, tchostmt;
		} V36;
		struct  {
			treeptr	twithvar, twithstmt;
		} V37;
		struct  {
			treeptr	texpw;
			declptr	tenv;
		} V38;
		struct  {
			treeptr	tvariable, toffset;
		} V39;
		struct  {
			treeptr	trecord, tfield;
		} V40;
		struct  {
			treeptr	texpl, texpr;
		} V41;
		struct  {
			treeptr	texps;
		} V42;
		struct  {
			symptr	tsym;
		} V43;
	} U;
}	treenode;
typedef enum { cabort, cbreak, ccontinue, cdefine,
	cdefault, cdouble, cedata, cenum,
	cetext, cextern, cfgetc, cfclose,
	cfflush, cfloat, cfloor, cfprintf,
	cfputc, cfread, cfscanf, cfwrite,
	cgetc, cgetpid, cint, cinclude,
	clong, clog, cmain, cmalloc,
	cprintf, cpower, cputc, cread,
	creturn, cregister, crewind, cscanf,
	csetbits, csetword, csetptr, cshort,
	csigned, csizeof, csprintf, cstdin,
	cstdout, cstderr, cstrncmp, cstrncpy,
	cstruct, cstatic, cswitch, ctypedef,
	cundef, cungetc, cunion, cunlink,
	cunsigned, cwrite } 	cnames;
typedef enum { ebadsymbol, elongstring, elongtokn, erange,
	emanytokn, enotdeclid, emultdeclid, enotdecllab,
	emultdecllab, emuldeflab, ebadstring, enulchr,
	ebadchar, eeofcmnt, eeofstr, evarpar,
	enew, esetbase, esetsize, eoverflow,
	etree, etag, euprconf, easgnconf,
	ecmpconf, econfconf, evrntfile, evarfile,
	emanymachs, ebadmach } 	errors;
typedef struct { char	A[machdeflen - 1 + 1]; }	machdefstr;
typedef struct { struct S206 {
	keyword	wrd;
	symtyp	sym;
}	A[keytablen + 1]; }	T63;
typedef struct { strptr	A[maxblkcnt + 1]; }	T64;
typedef struct { idptr	A[hashmax + 1]; }	T65;
typedef struct { treeptr	A[50]; }	T66;
typedef struct { symptr	A[50]; }	T67;
typedef struct { treeptr	A[11]; }	T68;
typedef struct { unsigned char	A[(int)(nnil) - (int)(nassign) + 1]; }	T69;
typedef struct { idptr	A[58]; }	T70;
typedef struct { struct S193 {
	integer	lolim, hilim;
	strindx	typstr;
}	A[maxmachdefs - 1 + 1]; }	T71;
typedef struct { char	A[15 + 1]; }	T72;
typedef struct { setword	S[2]; }	bitset;
integer	*G204_indnt;
integer	*G202_doarrow;
boolean	*G200_donearr;
boolean	*G198_dropset;
boolean	*G196_setused;
boolean	*G194_conflag;
integer	*G191_nelems;
treeptr	*G189_vp;
treeptr	*G187_tv;
symptr	*G185_iq;
symptr	*G183_ip;
unsigned char	*G181_lastchr;
toknidx	*G178_i;
toknbuf	*G176_t;
boolean	usemax, usejmps, usecase, usesets, useunion, usediff,
	usemksub, useintr, usesge, usesle, useseq, usesne,
	usememb, useins, usescpy, usecomp, usefopn, usescan,
	usegetl, usenilp, usebool;
treeptr	top;
treeptr	setlst;
integer	setcnt;
lexsym	currsym;
T63	keytab;
T64	strstor;
strindx	strfree;
strbidx	strleft;
T65	idtab;
declptr	symtab;
integer	statlvl, maxlevel;
T66	deftab;
T67	defnams;
T68	typnods;
T69	pprio, cprio;
T70	ctable;
unsigned char	nmachdefs;
T71	machdefs;
integer	lineno, colno, lastcol, lastline;
toknbuf	lasttok;
integer	varno;
T72	hexdig;

extern void error();
extern void fatal();
extern treeptr idup();
extern idptr mkconc();
extern treeptr mklit();
extern treeptr mknode();
extern idptr mkrename();
extern idptr mkvariable();
extern idptr mkvrnt();
extern treeptr newid();
extern treeptr oldid();
extern idptr saveid();
extern treeptr typeof();
extern treeptr xtrenum();
extern treeptr xtrit();
extern void etypedef();
