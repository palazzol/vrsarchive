/***************************************************************************/
/***************************************************************************/
/**									  **/
/**	Copyright (C) 1987 by Per Bergsten, Gothenburg, Sweden		  **/
/**									  **/
/**	No part of this program, or parts derived from this program,	  **/
/**	may be sold, hired or otherwise exploited without the author's	  **/
/**	written consent.						  **/
/**									  **/
/**	The program may be freely redistributed provided that:		  **/
/**									  **/
/**		1) the original program text, including this notice,	  **/
/**		   is reproduced unaltered,				  **/
/**		2) no charge (other than a nominal media cost) is	  **/
/**		   demanded for the copy.				  **/
/**									  **/
/**	The program may be included in a package only on the condition	  **/
/**	that the package as a whole is distributed at media cost.	  **/
/**									  **/
/***************************************************************************/
/***************************************************************************/
/**									  **/
/**	The program is a Pascal-to-C translator.			  **/
/**	It accepts a correct Pascal program and creates a C program	  **/
/**	with the same behaviour. It is not a complete compiler in the	  **/
/**	sense that it does NOT do complete typechecking or error-	  **/
/**	reporting. Only a minimal typecheck is done so that the meaning	  **/
/**	of each construct can be determined. Therefore, an incorrect	  **/
/**	Pascal program can easily cause the translator to malfunction.	  **/
/**									  **/
/***************************************************************************/
/***************************************************************************/
/**									  **/
/**	Things which are known to be dependent on the underlying cha-	  **/
/**	racterset are marked with a comment containing the word	CHAR.	  **/
/**	Things that are known to be dependent on the host operating	  **/
/**	system are marked with a comment containing the word OS.	  **/
/**	Things known to be dependent on the cpu and/or the target C-	  **/
/**	implementation are marked with the word CPU.			  **/
/**	Things dependent on the target C-library are marked with LIB.	  **/
/**									  **/
/**	The code generated by the translator assumes that there	is a	  **/
/**	C-implementation with at least a reasonable <stdio> library	  **/
/**	since all input/output is implemented in terms of C functions	  **/
/**	like fprintf(), getc(), fopen(), rewind() etc.			  **/
/**	If the source-program uses Pascal functions like sin(), sqrt()	  **/
/**	etc, there must also exist such functions in the C-library.	  **/
/**									  **/
/***************************************************************************/
#define EQUALS(c)	= c
#include "globals.h"

 void
prtmsg(m)
	errors	m;
{
	static char	user[]	= "Error: ";
	static char	restr[]	= "Implementation restriction: ";
	static char	inter[]	= "* Internal error * ";
# define xtoklen 64
	typedef struct { char	A[xtoklen - 1 + 1]; }	T73;
	toknidx	i;
	T73	xtok;

	switch (m) {
	  case ebadsymbol:
		(void)fprintf(stderr, "%sUnexpected symbol\n", user), Putl(output, 1);
		break ;
	  case ebadchar:
		(void)fprintf(stderr, "%sBad character\n", user), Putl(output, 1);
		break ;
	  case elongstring:
		(void)fprintf(stderr, "%sToo long string\n", restr), Putl(output, 1);
		break ;
	  case ebadstring:
		(void)fprintf(stderr, "%sNewline in string or character\n", user), Putl(output, 1);
		break ;
	  case eeofstr:
		(void)fprintf(stderr, "%sEnd of file in string or character\n", user), Putl(output, 1);
		break ;
	  case eeofcmnt:
		(void)fprintf(stderr, "%sEnd of file in comment\n", user), Putl(output, 1);
		break ;
	  case elongtokn:
		(void)fprintf(stderr, "%sToo long identfier\n", restr), Putl(output, 1);
		break ;
	  case emanytokn:
		(void)fprintf(stderr, "%sToo many strings, identifiers or real numbers\n", restr), Putl(output, 1);
		break ;
	  case enotdeclid:
		(void)fprintf(stderr, "%sIdentifier not declared\n", user), Putl(output, 1);
		break ;
	  case emultdeclid:
		(void)fprintf(stderr, "%sIdentifier declared twice\n", user), Putl(output, 1);
		break ;
	  case enotdecllab:
		(void)fprintf(stderr, "%sLabel not declared\n", user), Putl(output, 1);
		break ;
	  case emultdecllab:
		(void)fprintf(stderr, "%sLabel declared twice\n", user), Putl(output, 1);
		break ;
	  case emuldeflab:
		(void)fprintf(stderr, "%sLabel defined twice\n", user), Putl(output, 1);
		break ;
	  case evarpar:
		(void)fprintf(stderr, "%sActual parameter not a variable\n", user), Putl(output, 1);
		break ;
	  case enulchr:
		(void)fprintf(stderr, "%sCannot handle nul-character in strings\n", restr), Putl(output, 1);
		break ;
	  case enew:
		(void)fprintf(stderr, "%sNew returned a nil-pointer\n", restr), Putl(output, 1);
		break ;
	  case eoverflow:
		(void)fprintf(stderr, "%sToken buffer overflowed\n", restr), Putl(output, 1);
		break ;
	  case esetbase:
		(void)fprintf(stderr, "%sCannot handle sets with base >> 0\n", restr), Putl(output, 1);
		break ;
	  case esetsize:
		(void)fprintf(stderr, "%sCannot handle sets with very large range\n", restr), Putl(output, 1);
		break ;
	  case etree:
		(void)fprintf(stderr, "%sBad tree structure\n", inter), Putl(output, 1);
		break ;
	  case etag:
		(void)fprintf(stderr, "%sCannot find tag\n", inter), Putl(output, 1);
		break ;
	  case evrntfile:
		(void)fprintf(stderr, "%sCannot initialize files in record variants\n", restr), Putl(output, 1);
		break ;
	  case evarfile:
		(void)fprintf(stderr, "%sCannot handle files in structured variables\n", restr), Putl(output, 1);
		break ;
	  case euprconf:
		(void)fprintf(stderr, "%sNo upper bound on conformant arrays\n", inter), Putl(output, 1);
		break ;
	  case easgnconf:
		(void)fprintf(stderr, "%sCannot assign conformant arrays\n", inter), Putl(output, 1);
		break ;
	  case ecmpconf:
		(void)fprintf(stderr, "%sCannot compare conformant arrays\n", inter), Putl(output, 1);
		break ;
	  case econfconf:
		(void)fprintf(stderr, "%sCannot handle nested conformat arrays\n", restr), Putl(output, 1);
		break ;
	  case erange:
		(void)fprintf(stderr, "%sCannot find C-type for integer-subrange\n", inter), Putl(output, 1);
		break ;
	  case emanymachs:
		(void)fprintf(stderr, "%sToo many machine integer types\n", restr), Putl(output, 1);
		break ;
	  case ebadmach:
		(void)fprintf(stderr, "%sBad name for machine integer type\n", inter), Putl(output, 1);
		break ;
	  default:
		Caseerror(Line);
	}
	if (lastline != 0) {
		(void)fprintf(stderr, "Line %1d, col %1d:\n", lastline, lastcol), Putl(output, 1);
		if (Member((unsigned)(m), Conset[0])) {
			i = 1;
			while ((i < xtoklen) && (lasttok.A[i - 1] != null)) {
				xtok.A[i - 1] = lasttok.A[i - 1];
				i = i + 1;
			}
			while (i < xtoklen) {
				xtok.A[i - 1] = ' ';
				i = i + 1;
			}
			xtok.A[xtoklen - 1] = ' ';
			(void)fprintf(stderr, "Current symbol: %.64s\n", xtok.A), Putl(output, 1);
		}
	}
}

void fatal();

void error();

 char
uppercase(c)
	char	c;
{
	register char	R75;

	if ((c >= 'a') && (c <= 'z'))
		R75 = (unsigned)(c) + (unsigned)('A') - (unsigned)('a');
	else
		R75 = c;
	return R75;
}

 char
lowercase(c)
	char	c;
{
	register char	R76;

	if ((c >= 'A') && (c <= 'Z'))
		R76 = (unsigned)(c) - (unsigned)('A') + (unsigned)('a');
	else
		R76 = c;
	return R76;
}

 void
gettokn(i, t)
	strindx	i;
	toknbuf	*t;
{
	char	c;
	toknidx	k;
	strbidx	j;
	strptr	p;

	k = 1;
	p = strstor.A[i / (maxstrblk + 1)];
	j = i % (maxstrblk + 1);
	do {
		c = p->A[j];
		t->A[k - 1] = c;
		j = j + 1;
		k = k + 1;
		if (k == maxtoknlen) {
			c = null;
			t->A[maxtoknlen - 1] = null;
			prtmsg(eoverflow);
		}
	} while (!(c == null));
}

 void
puttokn(i, t)
	strindx	i;
	toknbuf	*t;
{
	char	c;
	toknidx	k;
	strbidx	j;
	strptr	p;

	k = 1;
	p = strstor.A[i / (maxstrblk + 1)];
	j = i % (maxstrblk + 1);
	do {
		c = t->A[k - 1];
		p->A[j] = c;
		k = k + 1;
		j = j + 1;
	} while (!(c == null));
}

 void
writetok(w)
	toknbuf	*w;
{
	toknidx	j;

	j = 1;
	while (w->A[j - 1] != null) {
		Putchr(w->A[j - 1], output);
		j = j + 1;
	}
}

 void
printtok(i)
	strindx	i;
{
	toknbuf	w;

	gettokn(i, &w);
	writetok(&w);
}

 void
printid(ip)
	idptr	ip;
{
	printtok(ip->istr);
}

 void
printchr(c)
	char	c;
{
	if ((c == quote) || (c == bslash))
		(void)fprintf(output.fp, "%c%c%c%c", quote, bslash, c, quote), Putl(output, 0);
	else
		(void)fprintf(output.fp, "%c%c%c", quote, c, quote), Putl(output, 0);
}

 void
printstr(i)
	strindx	i;
{
	toknidx	k;
	char	c;
	toknbuf	w;

	gettokn(i, &w);
	Putchr(cite, output);
	k = 1;
	while (w.A[k - 1] != null) {
		c = w.A[k - 1];
		k = k + 1;
		if ((c == cite) || (c == bslash))
			Putchr(bslash, output);
		Putchr(c, output);
	}
	Putchr(cite, output);
}

 treeptr
idup(ip)
	treeptr	ip;
{
	register treeptr	R77;

	R77 = ip->U.V43.tsym->lsymdecl->tup;
	return R77;
}

 hashtyp
hashtokn(id)
	toknbuf	*id;
{
	register hashtyp	R78;
	integer	h;
	toknidx	i;

	i = 1;
	h = 0;
	while (id->A[i - 1] != null) {
		h = h + (unsigned)(id->A[i - 1]);
		i = i + 1;
	}
	R78 = h % hashmax;
	return R78;
}

 strindx
savestr(t)
	toknbuf	*t;
{
	register strindx	R79;
	toknidx	k;
	strindx	i;
	strbcnt	j;

	k = 1;
	while (t->A[k - 1] != null)
		k = k + 1;
	if (k > strleft) {
		if (strstor.A[maxblkcnt] != (strblk *)NIL)
			error(emanytokn);
		j = (strfree + maxstrblk) / (maxstrblk + 1);
		strstor.A[j] = (strblk *)malloc((unsigned)(sizeof(*strstor.A[j])));
		if (strstor.A[j] == (strblk *)NIL)
			error(enew);
		strfree = j * (maxstrblk + 1);
		strleft = maxstrblk;
	}
	i = strfree;
	strfree = strfree + k;
	strleft = strleft - k;
	puttokn(i, &(*t));
	R79 = i;
	return R79;
}

 idptr
saveid(id)
	toknbuf	*id;
{
	register idptr	R80;
	toknidx	k;
	idptr	ip;
	hashtyp	h;
	toknbuf	t;

	h = hashtokn(&(*id));
	ip = idtab.A[h];
	while (ip != (struct S59 *)NIL) {
		gettokn(ip->istr, &t);
		k = 1;
		while (id->A[k - 1] == t.A[k - 1])
			if (id->A[k - 1] == null)
				goto L999;
			else
				k = k + 1;
		ip = ip->inext;
	}
	ip = (struct S59 *)malloc((unsigned)(sizeof(*ip)));
	if (ip == (struct S59 *)NIL)
		error(enew);
	ip->inref = 0;
	ip->istr = savestr(&(*id));
	ip->ihash = h;
	ip->inext = idtab.A[h];
	idtab.A[h] = ip;
L999:
	R80 = ip;
	return R80;
}

 idptr
mkconc(sep, p, q)
	char	sep;
	idptr	p, q;
{
	register idptr	R81;
	toknbuf	w, x;
	toknidx	i, j;

	gettokn(q->istr, &x);
	j = 1;
	while (x.A[j - 1] != null)
		j = j + 1;
	w.A[1 - 1] = null;
	if (p != (struct S59 *)NIL)
		gettokn(p->istr, &w);
	i = 1;
	while (w.A[i - 1] != null)
		i = i + 1;
	if (i + j + 2 >= maxtoknlen)
		error(eoverflow);
	if (sep == '>') {
		w.A[i - 1] = '-';
		i = i + 1;
	}
	if (sep != space) {
		w.A[i - 1] = sep;
		i = i + 1;
	}
	j = 1;
	do {
		w.A[i - 1] = x.A[j - 1];
		i = i + 1;
		j = j + 1;
	} while (!(w.A[i - 1 - 1] == null));
	R81 = saveid(&w);
	return R81;
}

idptr mkuniqname();

 void
dig(n)
	integer	n;
{
	if (n > 0) {
		dig(n / 10);
		if ((*G178_i) == maxtoknlen)
			error(eoverflow);
		(*G176_t).A[(*G178_i) - 1] = n % 10 + (unsigned)('0');
		(*G178_i) = (*G178_i) + 1;
	}
}

 idptr
mkuniqname(t)
	toknbuf	*t;
{
	register idptr	R82;
	toknidx	i;
	toknbuf	*F177;
	toknidx	*F179;

	F179 = G178_i;
	G178_i = &i;
	F177 = G176_t;
	G176_t = &(*t);
	(*G178_i) = 1;
	while ((*G176_t).A[(*G178_i) - 1] != null)
		(*G178_i) = (*G178_i) + 1;
	varno = varno + 1;
	dig(varno);
	(*G176_t).A[(*G178_i) - 1] = null;
	R82 = saveid(&(*G176_t));
	G176_t = F177;
	G178_i = F179;
	return R82;
}

 idptr
mkvariable(c)
	char	c;
{
	register idptr	R83;
	toknbuf	t;

	t.A[1 - 1] = c;
	t.A[2 - 1] = null;
	R83 = mkuniqname(&t);
	return R83;
}

 idptr
mkrename(c, ip)
	char	c;
	idptr	ip;
{
	register idptr	R84;

	R84 = mkconc(uscore, mkvariable(c), ip);
	return R84;
}

 idptr
mkvrnt()
{
	register idptr	R85;
	toknbuf	t;

	t.A[1 - 1] = 'U';
	t.A[2 - 1] = '.';
	t.A[3 - 1] = 'V';
	t.A[4 - 1] = null;
	R85 = mkuniqname(&t);
	return R85;
}
